/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace LibNFTOrder {
  export type FeeStruct = {
    recipient: AddressLike;
    amount: BigNumberish;
    feeData: BytesLike;
  };

  export type FeeStructOutput = [
    recipient: string,
    amount: bigint,
    feeData: string
  ] & { recipient: string; amount: bigint; feeData: string };

  export type PropertyStruct = {
    propertyValidator: AddressLike;
    propertyData: BytesLike;
  };

  export type PropertyStructOutput = [
    propertyValidator: string,
    propertyData: string
  ] & { propertyValidator: string; propertyData: string };

  export type ERC1155OrderStruct = {
    direction: BigNumberish;
    maker: AddressLike;
    taker: AddressLike;
    expiry: BigNumberish;
    nonce: BigNumberish;
    erc20Token: AddressLike;
    erc20TokenAmount: BigNumberish;
    fees: LibNFTOrder.FeeStruct[];
    erc1155Token: AddressLike;
    erc1155TokenId: BigNumberish;
    erc1155TokenProperties: LibNFTOrder.PropertyStruct[];
    erc1155TokenAmount: BigNumberish;
  };

  export type ERC1155OrderStructOutput = [
    direction: bigint,
    maker: string,
    taker: string,
    expiry: bigint,
    nonce: bigint,
    erc20Token: string,
    erc20TokenAmount: bigint,
    fees: LibNFTOrder.FeeStructOutput[],
    erc1155Token: string,
    erc1155TokenId: bigint,
    erc1155TokenProperties: LibNFTOrder.PropertyStructOutput[],
    erc1155TokenAmount: bigint
  ] & {
    direction: bigint;
    maker: string;
    taker: string;
    expiry: bigint;
    nonce: bigint;
    erc20Token: string;
    erc20TokenAmount: bigint;
    fees: LibNFTOrder.FeeStructOutput[];
    erc1155Token: string;
    erc1155TokenId: bigint;
    erc1155TokenProperties: LibNFTOrder.PropertyStructOutput[];
    erc1155TokenAmount: bigint;
  };

  export type ERC721OrderStruct = {
    direction: BigNumberish;
    maker: AddressLike;
    taker: AddressLike;
    expiry: BigNumberish;
    nonce: BigNumberish;
    erc20Token: AddressLike;
    erc20TokenAmount: BigNumberish;
    fees: LibNFTOrder.FeeStruct[];
    erc721Token: AddressLike;
    erc721TokenId: BigNumberish;
    erc721TokenProperties: LibNFTOrder.PropertyStruct[];
  };

  export type ERC721OrderStructOutput = [
    direction: bigint,
    maker: string,
    taker: string,
    expiry: bigint,
    nonce: bigint,
    erc20Token: string,
    erc20TokenAmount: bigint,
    fees: LibNFTOrder.FeeStructOutput[],
    erc721Token: string,
    erc721TokenId: bigint,
    erc721TokenProperties: LibNFTOrder.PropertyStructOutput[]
  ] & {
    direction: bigint;
    maker: string;
    taker: string;
    expiry: bigint;
    nonce: bigint;
    erc20Token: string;
    erc20TokenAmount: bigint;
    fees: LibNFTOrder.FeeStructOutput[];
    erc721Token: string;
    erc721TokenId: bigint;
    erc721TokenProperties: LibNFTOrder.PropertyStructOutput[];
  };

  export type OrderInfoStruct = {
    orderHash: BytesLike;
    status: BigNumberish;
    orderAmount: BigNumberish;
    remainingAmount: BigNumberish;
  };

  export type OrderInfoStructOutput = [
    orderHash: string,
    status: bigint,
    orderAmount: bigint,
    remainingAmount: bigint
  ] & {
    orderHash: string;
    status: bigint;
    orderAmount: bigint;
    remainingAmount: bigint;
  };
}

export declare namespace LibNativeOrder {
  export type LimitOrderStruct = {
    makerToken: AddressLike;
    takerToken: AddressLike;
    makerAmount: BigNumberish;
    takerAmount: BigNumberish;
    takerTokenFeeAmount: BigNumberish;
    maker: AddressLike;
    taker: AddressLike;
    sender: AddressLike;
    feeRecipient: AddressLike;
    pool: BytesLike;
    expiry: BigNumberish;
    salt: BigNumberish;
  };

  export type LimitOrderStructOutput = [
    makerToken: string,
    takerToken: string,
    makerAmount: bigint,
    takerAmount: bigint,
    takerTokenFeeAmount: bigint,
    maker: string,
    taker: string,
    sender: string,
    feeRecipient: string,
    pool: string,
    expiry: bigint,
    salt: bigint
  ] & {
    makerToken: string;
    takerToken: string;
    makerAmount: bigint;
    takerAmount: bigint;
    takerTokenFeeAmount: bigint;
    maker: string;
    taker: string;
    sender: string;
    feeRecipient: string;
    pool: string;
    expiry: bigint;
    salt: bigint;
  };

  export type OtcOrderStruct = {
    makerToken: AddressLike;
    takerToken: AddressLike;
    makerAmount: BigNumberish;
    takerAmount: BigNumberish;
    maker: AddressLike;
    taker: AddressLike;
    txOrigin: AddressLike;
    expiryAndNonce: BigNumberish;
  };

  export type OtcOrderStructOutput = [
    makerToken: string,
    takerToken: string,
    makerAmount: bigint,
    takerAmount: bigint,
    maker: string,
    taker: string,
    txOrigin: string,
    expiryAndNonce: bigint
  ] & {
    makerToken: string;
    takerToken: string;
    makerAmount: bigint;
    takerAmount: bigint;
    maker: string;
    taker: string;
    txOrigin: string;
    expiryAndNonce: bigint;
  };

  export type RfqOrderStruct = {
    makerToken: AddressLike;
    takerToken: AddressLike;
    makerAmount: BigNumberish;
    takerAmount: BigNumberish;
    maker: AddressLike;
    taker: AddressLike;
    txOrigin: AddressLike;
    pool: BytesLike;
    expiry: BigNumberish;
    salt: BigNumberish;
  };

  export type RfqOrderStructOutput = [
    makerToken: string,
    takerToken: string,
    makerAmount: bigint,
    takerAmount: bigint,
    maker: string,
    taker: string,
    txOrigin: string,
    pool: string,
    expiry: bigint,
    salt: bigint
  ] & {
    makerToken: string;
    takerToken: string;
    makerAmount: bigint;
    takerAmount: bigint;
    maker: string;
    taker: string;
    txOrigin: string;
    pool: string;
    expiry: bigint;
    salt: bigint;
  };

  export type OrderInfoStruct = {
    orderHash: BytesLike;
    status: BigNumberish;
    takerTokenFilledAmount: BigNumberish;
  };

  export type OrderInfoStructOutput = [
    orderHash: string,
    status: bigint,
    takerTokenFilledAmount: bigint
  ] & { orderHash: string; status: bigint; takerTokenFilledAmount: bigint };

  export type OtcOrderInfoStruct = {
    orderHash: BytesLike;
    status: BigNumberish;
  };

  export type OtcOrderInfoStructOutput = [orderHash: string, status: bigint] & {
    orderHash: string;
    status: bigint;
  };
}

export declare namespace LibSignature {
  export type SignatureStruct = {
    signatureType: BigNumberish;
    v: BigNumberish;
    r: BytesLike;
    s: BytesLike;
  };

  export type SignatureStructOutput = [
    signatureType: bigint,
    v: bigint,
    r: string,
    s: string
  ] & { signatureType: bigint; v: bigint; r: string; s: string };
}

export declare namespace IMultiplexFeature {
  export type BatchSellSubcallStruct = {
    id: BigNumberish;
    sellAmount: BigNumberish;
    data: BytesLike;
  };

  export type BatchSellSubcallStructOutput = [
    id: bigint,
    sellAmount: bigint,
    data: string
  ] & { id: bigint; sellAmount: bigint; data: string };

  export type BatchSellParamsStruct = {
    inputToken: AddressLike;
    outputToken: AddressLike;
    sellAmount: BigNumberish;
    calls: IMultiplexFeature.BatchSellSubcallStruct[];
    useSelfBalance: boolean;
    recipient: AddressLike;
    payer: AddressLike;
  };

  export type BatchSellParamsStructOutput = [
    inputToken: string,
    outputToken: string,
    sellAmount: bigint,
    calls: IMultiplexFeature.BatchSellSubcallStructOutput[],
    useSelfBalance: boolean,
    recipient: string,
    payer: string
  ] & {
    inputToken: string;
    outputToken: string;
    sellAmount: bigint;
    calls: IMultiplexFeature.BatchSellSubcallStructOutput[];
    useSelfBalance: boolean;
    recipient: string;
    payer: string;
  };

  export type MultiHopSellSubcallStruct = { id: BigNumberish; data: BytesLike };

  export type MultiHopSellSubcallStructOutput = [id: bigint, data: string] & {
    id: bigint;
    data: string;
  };

  export type MultiHopSellParamsStruct = {
    tokens: AddressLike[];
    sellAmount: BigNumberish;
    calls: IMultiplexFeature.MultiHopSellSubcallStruct[];
    useSelfBalance: boolean;
    recipient: AddressLike;
    payer: AddressLike;
  };

  export type MultiHopSellParamsStructOutput = [
    tokens: string[],
    sellAmount: bigint,
    calls: IMultiplexFeature.MultiHopSellSubcallStructOutput[],
    useSelfBalance: boolean,
    recipient: string,
    payer: string
  ] & {
    tokens: string[];
    sellAmount: bigint;
    calls: IMultiplexFeature.MultiHopSellSubcallStructOutput[];
    useSelfBalance: boolean;
    recipient: string;
    payer: string;
  };
}

export declare namespace ITransformERC20Feature {
  export type TransformationStruct = {
    deploymentNonce: BigNumberish;
    data: BytesLike;
  };

  export type TransformationStructOutput = [
    deploymentNonce: bigint,
    data: string
  ] & { deploymentNonce: bigint; data: string };

  export type TransformERC20ArgsStruct = {
    taker: AddressLike;
    inputToken: AddressLike;
    outputToken: AddressLike;
    inputTokenAmount: BigNumberish;
    minOutputTokenAmount: BigNumberish;
    transformations: ITransformERC20Feature.TransformationStruct[];
    useSelfBalance: boolean;
    recipient: AddressLike;
  };

  export type TransformERC20ArgsStructOutput = [
    taker: string,
    inputToken: string,
    outputToken: string,
    inputTokenAmount: bigint,
    minOutputTokenAmount: bigint,
    transformations: ITransformERC20Feature.TransformationStructOutput[],
    useSelfBalance: boolean,
    recipient: string
  ] & {
    taker: string;
    inputToken: string;
    outputToken: string;
    inputTokenAmount: bigint;
    minOutputTokenAmount: bigint;
    transformations: ITransformERC20Feature.TransformationStructOutput[];
    useSelfBalance: boolean;
    recipient: string;
  };
}

export declare namespace IMetaTransactionsFeature {
  export type MetaTransactionDataStruct = {
    signer: AddressLike;
    sender: AddressLike;
    minGasPrice: BigNumberish;
    maxGasPrice: BigNumberish;
    expirationTimeSeconds: BigNumberish;
    salt: BigNumberish;
    callData: BytesLike;
    value: BigNumberish;
    feeToken: AddressLike;
    feeAmount: BigNumberish;
  };

  export type MetaTransactionDataStructOutput = [
    signer: string,
    sender: string,
    minGasPrice: bigint,
    maxGasPrice: bigint,
    expirationTimeSeconds: bigint,
    salt: bigint,
    callData: string,
    value: bigint,
    feeToken: string,
    feeAmount: bigint
  ] & {
    signer: string;
    sender: string;
    minGasPrice: bigint;
    maxGasPrice: bigint;
    expirationTimeSeconds: bigint;
    salt: bigint;
    callData: string;
    value: bigint;
    feeToken: string;
    feeAmount: bigint;
  };
}

export declare namespace IMetaTransactionsFeatureV2 {
  export type MetaTransactionFeeDataStruct = {
    recipient: AddressLike;
    amount: BigNumberish;
  };

  export type MetaTransactionFeeDataStructOutput = [
    recipient: string,
    amount: bigint
  ] & { recipient: string; amount: bigint };

  export type MetaTransactionDataV2Struct = {
    signer: AddressLike;
    sender: AddressLike;
    expirationTimeSeconds: BigNumberish;
    salt: BigNumberish;
    callData: BytesLike;
    feeToken: AddressLike;
    fees: IMetaTransactionsFeatureV2.MetaTransactionFeeDataStruct[];
  };

  export type MetaTransactionDataV2StructOutput = [
    signer: string,
    sender: string,
    expirationTimeSeconds: bigint,
    salt: bigint,
    callData: string,
    feeToken: string,
    fees: IMetaTransactionsFeatureV2.MetaTransactionFeeDataStructOutput[]
  ] & {
    signer: string;
    sender: string;
    expirationTimeSeconds: bigint;
    salt: bigint;
    callData: string;
    feeToken: string;
    fees: IMetaTransactionsFeatureV2.MetaTransactionFeeDataStructOutput[];
  };
}

export interface IZeroExInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "_fillLimitOrder"
      | "_fillOtcOrder"
      | "_fillRfqOrder"
      | "_multiplexBatchSell"
      | "_multiplexMultiHopSell"
      | "_sellHeldTokenForTokenToUniswapV3"
      | "_sellTokenForTokenToUniswapV3"
      | "_transformERC20"
      | "batchBuyERC1155s"
      | "batchBuyERC721s"
      | "batchCancelERC1155Orders"
      | "batchCancelERC721Orders"
      | "batchCancelLimitOrders"
      | "batchCancelPairLimitOrders"
      | "batchCancelPairLimitOrdersWithSigner"
      | "batchCancelPairRfqOrders"
      | "batchCancelPairRfqOrdersWithSigner"
      | "batchCancelRfqOrders"
      | "batchExecuteMetaTransactions"
      | "batchExecuteMetaTransactionsV2"
      | "batchFillLimitOrders"
      | "batchFillRfqOrders"
      | "batchFillTakerSignedOtcOrders"
      | "batchGetLimitOrderRelevantStates"
      | "batchGetRfqOrderRelevantStates"
      | "batchMatchERC721Orders"
      | "buyERC1155"
      | "buyERC721"
      | "cancelERC1155Order"
      | "cancelERC721Order"
      | "cancelLimitOrder"
      | "cancelPairLimitOrders"
      | "cancelPairLimitOrdersWithSigner"
      | "cancelPairRfqOrders"
      | "cancelPairRfqOrdersWithSigner"
      | "cancelRfqOrder"
      | "createTransformWallet"
      | "executeMetaTransaction"
      | "executeMetaTransactionV2"
      | "extend"
      | "fillLimitOrder"
      | "fillOrKillLimitOrder"
      | "fillOrKillRfqOrder"
      | "fillOtcOrder"
      | "fillOtcOrderForEth"
      | "fillOtcOrderWithEth"
      | "fillRfqOrder"
      | "fillTakerSignedOtcOrder"
      | "fillTakerSignedOtcOrderForEth"
      | "getERC1155OrderHash"
      | "getERC1155OrderInfo"
      | "getERC721OrderHash"
      | "getERC721OrderStatus"
      | "getERC721OrderStatusBitVector"
      | "getLimitOrderHash"
      | "getLimitOrderInfo"
      | "getLimitOrderRelevantState"
      | "getMetaTransactionExecutedBlock"
      | "getMetaTransactionHash"
      | "getMetaTransactionHashExecutedBlock"
      | "getMetaTransactionV2ExecutedBlock"
      | "getMetaTransactionV2Hash"
      | "getMetaTransactionV2HashExecutedBlock"
      | "getOtcOrderHash"
      | "getOtcOrderInfo"
      | "getProtocolFeeMultiplier"
      | "getQuoteSigner"
      | "getRfqOrderHash"
      | "getRfqOrderInfo"
      | "getRfqOrderRelevantState"
      | "getRollbackEntryAtIndex"
      | "getRollbackLength"
      | "getTransformWallet"
      | "getTransformerDeployer"
      | "isValidOrderSigner"
      | "lastOtcTxOriginNonce"
      | "matchERC721Orders"
      | "migrate"
      | "multiplexBatchSellEthForToken"
      | "multiplexBatchSellTokenForEth"
      | "multiplexBatchSellTokenForToken"
      | "multiplexMultiHopSellEthForToken"
      | "multiplexMultiHopSellTokenForEth"
      | "multiplexMultiHopSellTokenForToken"
      | "onERC1155Received"
      | "onERC721Received"
      | "owner"
      | "preSignERC1155Order"
      | "preSignERC721Order"
      | "registerAllowedOrderSigner"
      | "registerAllowedRfqOrigins"
      | "rollback"
      | "sellERC1155"
      | "sellERC721"
      | "sellEthForTokenToUniswapV3"
      | "sellToLiquidityProvider"
      | "sellToPancakeSwap"
      | "sellToUniswap"
      | "sellTokenForEthToUniswapV3"
      | "sellTokenForTokenToUniswapV3"
      | "setQuoteSigner"
      | "setTransformerDeployer"
      | "supportInterface"
      | "transferOwnership"
      | "transferProtocolFeesForPools"
      | "transferTrappedTokensTo"
      | "transformERC20"
      | "uniswapV3SwapCallback"
      | "validateERC1155OrderProperties"
      | "validateERC1155OrderSignature"
      | "validateERC721OrderProperties"
      | "validateERC721OrderSignature"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ERC1155OrderCancelled"
      | "ERC1155OrderFilled"
      | "ERC1155OrderPreSigned"
      | "ERC721OrderCancelled"
      | "ERC721OrderFilled"
      | "ERC721OrderPreSigned"
      | "LimitOrderFilled"
      | "LiquidityProviderSwap"
      | "MetaTransactionExecuted"
      | "MetaTransactionExecutedV2"
      | "Migrated"
      | "OrderCancelled"
      | "OrderSignerRegistered"
      | "OtcOrderFilled"
      | "OwnershipTransferred"
      | "PairCancelledLimitOrders"
      | "PairCancelledRfqOrders"
      | "ProxyFunctionUpdated"
      | "QuoteSignerUpdated"
      | "RfqOrderFilled"
      | "RfqOrderOriginsAllowed"
      | "TransformedERC20"
      | "TransformerDeployerUpdated"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "_fillLimitOrder",
    values: [
      LibNativeOrder.LimitOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish,
      AddressLike,
      AddressLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_fillOtcOrder",
    values: [
      LibNativeOrder.OtcOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish,
      AddressLike,
      boolean,
      AddressLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_fillRfqOrder",
    values: [
      LibNativeOrder.RfqOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish,
      AddressLike,
      boolean,
      AddressLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_multiplexBatchSell",
    values: [IMultiplexFeature.BatchSellParamsStruct, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_multiplexMultiHopSell",
    values: [IMultiplexFeature.MultiHopSellParamsStruct, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_sellHeldTokenForTokenToUniswapV3",
    values: [BytesLike, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "_sellTokenForTokenToUniswapV3",
    values: [BytesLike, BigNumberish, BigNumberish, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "_transformERC20",
    values: [ITransformERC20Feature.TransformERC20ArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "batchBuyERC1155s",
    values: [
      LibNFTOrder.ERC1155OrderStruct[],
      LibSignature.SignatureStruct[],
      BigNumberish[],
      BytesLike[],
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchBuyERC721s",
    values: [
      LibNFTOrder.ERC721OrderStruct[],
      LibSignature.SignatureStruct[],
      BytesLike[],
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelERC1155Orders",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelERC721Orders",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelLimitOrders",
    values: [LibNativeOrder.LimitOrderStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairLimitOrders",
    values: [AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairLimitOrdersWithSigner",
    values: [AddressLike, AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairRfqOrders",
    values: [AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairRfqOrdersWithSigner",
    values: [AddressLike, AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelRfqOrders",
    values: [LibNativeOrder.RfqOrderStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchExecuteMetaTransactions",
    values: [
      IMetaTransactionsFeature.MetaTransactionDataStruct[],
      LibSignature.SignatureStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchExecuteMetaTransactionsV2",
    values: [
      IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct[],
      LibSignature.SignatureStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFillLimitOrders",
    values: [
      LibNativeOrder.LimitOrderStruct[],
      LibSignature.SignatureStruct[],
      BigNumberish[],
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFillRfqOrders",
    values: [
      LibNativeOrder.RfqOrderStruct[],
      LibSignature.SignatureStruct[],
      BigNumberish[],
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFillTakerSignedOtcOrders",
    values: [
      LibNativeOrder.OtcOrderStruct[],
      LibSignature.SignatureStruct[],
      LibSignature.SignatureStruct[],
      boolean[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchGetLimitOrderRelevantStates",
    values: [LibNativeOrder.LimitOrderStruct[], LibSignature.SignatureStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchGetRfqOrderRelevantStates",
    values: [LibNativeOrder.RfqOrderStruct[], LibSignature.SignatureStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchMatchERC721Orders",
    values: [
      LibNFTOrder.ERC721OrderStruct[],
      LibNFTOrder.ERC721OrderStruct[],
      LibSignature.SignatureStruct[],
      LibSignature.SignatureStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "buyERC1155",
    values: [
      LibNFTOrder.ERC1155OrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "buyERC721",
    values: [
      LibNFTOrder.ERC721OrderStruct,
      LibSignature.SignatureStruct,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelERC1155Order",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelERC721Order",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelLimitOrder",
    values: [LibNativeOrder.LimitOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairLimitOrders",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairLimitOrdersWithSigner",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairRfqOrders",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairRfqOrdersWithSigner",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelRfqOrder",
    values: [LibNativeOrder.RfqOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createTransformWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [
      IMetaTransactionsFeature.MetaTransactionDataStruct,
      LibSignature.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransactionV2",
    values: [
      IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct,
      LibSignature.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "extend",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fillLimitOrder",
    values: [
      LibNativeOrder.LimitOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrKillLimitOrder",
    values: [
      LibNativeOrder.LimitOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrKillRfqOrder",
    values: [
      LibNativeOrder.RfqOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOtcOrder",
    values: [
      LibNativeOrder.OtcOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOtcOrderForEth",
    values: [
      LibNativeOrder.OtcOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOtcOrderWithEth",
    values: [LibNativeOrder.OtcOrderStruct, LibSignature.SignatureStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "fillRfqOrder",
    values: [
      LibNativeOrder.RfqOrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillTakerSignedOtcOrder",
    values: [
      LibNativeOrder.OtcOrderStruct,
      LibSignature.SignatureStruct,
      LibSignature.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillTakerSignedOtcOrderForEth",
    values: [
      LibNativeOrder.OtcOrderStruct,
      LibSignature.SignatureStruct,
      LibSignature.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getERC1155OrderHash",
    values: [LibNFTOrder.ERC1155OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getERC1155OrderInfo",
    values: [LibNFTOrder.ERC1155OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getERC721OrderHash",
    values: [LibNFTOrder.ERC721OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getERC721OrderStatus",
    values: [LibNFTOrder.ERC721OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getERC721OrderStatusBitVector",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderHash",
    values: [LibNativeOrder.LimitOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderInfo",
    values: [LibNativeOrder.LimitOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderRelevantState",
    values: [LibNativeOrder.LimitOrderStruct, LibSignature.SignatureStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionExecutedBlock",
    values: [IMetaTransactionsFeature.MetaTransactionDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionHash",
    values: [IMetaTransactionsFeature.MetaTransactionDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionHashExecutedBlock",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionV2ExecutedBlock",
    values: [IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionV2Hash",
    values: [IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaTransactionV2HashExecutedBlock",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getOtcOrderHash",
    values: [LibNativeOrder.OtcOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getOtcOrderInfo",
    values: [LibNativeOrder.OtcOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getProtocolFeeMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getQuoteSigner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderHash",
    values: [LibNativeOrder.RfqOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderInfo",
    values: [LibNativeOrder.RfqOrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderRelevantState",
    values: [LibNativeOrder.RfqOrderStruct, LibSignature.SignatureStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getRollbackEntryAtIndex",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRollbackLength",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTransformWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTransformerDeployer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isValidOrderSigner",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "lastOtcTxOriginNonce",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "matchERC721Orders",
    values: [
      LibNFTOrder.ERC721OrderStruct,
      LibNFTOrder.ERC721OrderStruct,
      LibSignature.SignatureStruct,
      LibSignature.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "migrate",
    values: [AddressLike, BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "multiplexBatchSellEthForToken",
    values: [
      AddressLike,
      IMultiplexFeature.BatchSellSubcallStruct[],
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multiplexBatchSellTokenForEth",
    values: [
      AddressLike,
      IMultiplexFeature.BatchSellSubcallStruct[],
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multiplexBatchSellTokenForToken",
    values: [
      AddressLike,
      AddressLike,
      IMultiplexFeature.BatchSellSubcallStruct[],
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multiplexMultiHopSellEthForToken",
    values: [
      AddressLike[],
      IMultiplexFeature.MultiHopSellSubcallStruct[],
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multiplexMultiHopSellTokenForEth",
    values: [
      AddressLike[],
      IMultiplexFeature.MultiHopSellSubcallStruct[],
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multiplexMultiHopSellTokenForToken",
    values: [
      AddressLike[],
      IMultiplexFeature.MultiHopSellSubcallStruct[],
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "preSignERC1155Order",
    values: [LibNFTOrder.ERC1155OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "preSignERC721Order",
    values: [LibNFTOrder.ERC721OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAllowedOrderSigner",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAllowedRfqOrigins",
    values: [AddressLike[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "rollback",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sellERC1155",
    values: [
      LibNFTOrder.ERC1155OrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish,
      BigNumberish,
      boolean,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sellERC721",
    values: [
      LibNFTOrder.ERC721OrderStruct,
      LibSignature.SignatureStruct,
      BigNumberish,
      boolean,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sellEthForTokenToUniswapV3",
    values: [BytesLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sellToLiquidityProvider",
    values: [
      AddressLike,
      AddressLike,
      AddressLike,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sellToPancakeSwap",
    values: [AddressLike[], BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellToUniswap",
    values: [AddressLike[], BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "sellTokenForEthToUniswapV3",
    values: [BytesLike, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sellTokenForTokenToUniswapV3",
    values: [BytesLike, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setQuoteSigner",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setTransformerDeployer",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferProtocolFeesForPools",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTrappedTokensTo",
    values: [AddressLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transformERC20",
    values: [
      AddressLike,
      AddressLike,
      BigNumberish,
      BigNumberish,
      ITransformERC20Feature.TransformationStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV3SwapCallback",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validateERC1155OrderProperties",
    values: [LibNFTOrder.ERC1155OrderStruct, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "validateERC1155OrderSignature",
    values: [LibNFTOrder.ERC1155OrderStruct, LibSignature.SignatureStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "validateERC721OrderProperties",
    values: [LibNFTOrder.ERC721OrderStruct, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "validateERC721OrderSignature",
    values: [LibNFTOrder.ERC721OrderStruct, LibSignature.SignatureStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "_fillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_fillOtcOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_fillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_multiplexBatchSell",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_multiplexMultiHopSell",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_sellHeldTokenForTokenToUniswapV3",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_sellTokenForTokenToUniswapV3",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_transformERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchBuyERC1155s",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchBuyERC721s",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelERC1155Orders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelERC721Orders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairLimitOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairRfqOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchExecuteMetaTransactions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchExecuteMetaTransactionsV2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchFillLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchFillRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchFillTakerSignedOtcOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchGetLimitOrderRelevantStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchGetRfqOrderRelevantStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchMatchERC721Orders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "buyERC1155", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buyERC721", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelERC1155Order",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelERC721Order",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairLimitOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairRfqOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createTransformWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransactionV2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "extend", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrKillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrKillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOtcOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOtcOrderForEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOtcOrderWithEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillTakerSignedOtcOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillTakerSignedOtcOrderForEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getERC1155OrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getERC1155OrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getERC721OrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getERC721OrderStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getERC721OrderStatusBitVector",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderRelevantState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionExecutedBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionHashExecutedBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionV2ExecutedBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionV2Hash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaTransactionV2HashExecutedBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOtcOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOtcOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProtocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getQuoteSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderRelevantState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRollbackEntryAtIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRollbackLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransformWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransformerDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidOrderSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastOtcTxOriginNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "matchERC721Orders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "migrate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "multiplexBatchSellEthForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiplexBatchSellTokenForEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiplexBatchSellTokenForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiplexMultiHopSellEthForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiplexMultiHopSellTokenForEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiplexMultiHopSellTokenForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "preSignERC1155Order",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preSignERC721Order",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAllowedOrderSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAllowedRfqOrigins",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rollback", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellERC1155",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sellERC721", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellEthForTokenToUniswapV3",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellToLiquidityProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellToPancakeSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellToUniswap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellTokenForEthToUniswapV3",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellTokenForTokenToUniswapV3",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setQuoteSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTransformerDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferProtocolFeesForPools",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTrappedTokensTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transformERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV3SwapCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateERC1155OrderProperties",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateERC1155OrderSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateERC721OrderProperties",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateERC721OrderSignature",
    data: BytesLike
  ): Result;
}

export namespace ERC1155OrderCancelledEvent {
  export type InputTuple = [maker: AddressLike, nonce: BigNumberish];
  export type OutputTuple = [maker: string, nonce: bigint];
  export interface OutputObject {
    maker: string;
    nonce: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ERC1155OrderFilledEvent {
  export type InputTuple = [
    direction: BigNumberish,
    maker: AddressLike,
    taker: AddressLike,
    nonce: BigNumberish,
    erc20Token: AddressLike,
    erc20FillAmount: BigNumberish,
    erc1155Token: AddressLike,
    erc1155TokenId: BigNumberish,
    erc1155FillAmount: BigNumberish,
    matcher: AddressLike
  ];
  export type OutputTuple = [
    direction: bigint,
    maker: string,
    taker: string,
    nonce: bigint,
    erc20Token: string,
    erc20FillAmount: bigint,
    erc1155Token: string,
    erc1155TokenId: bigint,
    erc1155FillAmount: bigint,
    matcher: string
  ];
  export interface OutputObject {
    direction: bigint;
    maker: string;
    taker: string;
    nonce: bigint;
    erc20Token: string;
    erc20FillAmount: bigint;
    erc1155Token: string;
    erc1155TokenId: bigint;
    erc1155FillAmount: bigint;
    matcher: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ERC1155OrderPreSignedEvent {
  export type InputTuple = [
    direction: BigNumberish,
    maker: AddressLike,
    taker: AddressLike,
    expiry: BigNumberish,
    nonce: BigNumberish,
    erc20Token: AddressLike,
    erc20TokenAmount: BigNumberish,
    fees: LibNFTOrder.FeeStruct[],
    erc1155Token: AddressLike,
    erc1155TokenId: BigNumberish,
    erc1155TokenProperties: LibNFTOrder.PropertyStruct[],
    erc1155TokenAmount: BigNumberish
  ];
  export type OutputTuple = [
    direction: bigint,
    maker: string,
    taker: string,
    expiry: bigint,
    nonce: bigint,
    erc20Token: string,
    erc20TokenAmount: bigint,
    fees: LibNFTOrder.FeeStructOutput[],
    erc1155Token: string,
    erc1155TokenId: bigint,
    erc1155TokenProperties: LibNFTOrder.PropertyStructOutput[],
    erc1155TokenAmount: bigint
  ];
  export interface OutputObject {
    direction: bigint;
    maker: string;
    taker: string;
    expiry: bigint;
    nonce: bigint;
    erc20Token: string;
    erc20TokenAmount: bigint;
    fees: LibNFTOrder.FeeStructOutput[];
    erc1155Token: string;
    erc1155TokenId: bigint;
    erc1155TokenProperties: LibNFTOrder.PropertyStructOutput[];
    erc1155TokenAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ERC721OrderCancelledEvent {
  export type InputTuple = [maker: AddressLike, nonce: BigNumberish];
  export type OutputTuple = [maker: string, nonce: bigint];
  export interface OutputObject {
    maker: string;
    nonce: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ERC721OrderFilledEvent {
  export type InputTuple = [
    direction: BigNumberish,
    maker: AddressLike,
    taker: AddressLike,
    nonce: BigNumberish,
    erc20Token: AddressLike,
    erc20TokenAmount: BigNumberish,
    erc721Token: AddressLike,
    erc721TokenId: BigNumberish,
    matcher: AddressLike
  ];
  export type OutputTuple = [
    direction: bigint,
    maker: string,
    taker: string,
    nonce: bigint,
    erc20Token: string,
    erc20TokenAmount: bigint,
    erc721Token: string,
    erc721TokenId: bigint,
    matcher: string
  ];
  export interface OutputObject {
    direction: bigint;
    maker: string;
    taker: string;
    nonce: bigint;
    erc20Token: string;
    erc20TokenAmount: bigint;
    erc721Token: string;
    erc721TokenId: bigint;
    matcher: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ERC721OrderPreSignedEvent {
  export type InputTuple = [
    direction: BigNumberish,
    maker: AddressLike,
    taker: AddressLike,
    expiry: BigNumberish,
    nonce: BigNumberish,
    erc20Token: AddressLike,
    erc20TokenAmount: BigNumberish,
    fees: LibNFTOrder.FeeStruct[],
    erc721Token: AddressLike,
    erc721TokenId: BigNumberish,
    erc721TokenProperties: LibNFTOrder.PropertyStruct[]
  ];
  export type OutputTuple = [
    direction: bigint,
    maker: string,
    taker: string,
    expiry: bigint,
    nonce: bigint,
    erc20Token: string,
    erc20TokenAmount: bigint,
    fees: LibNFTOrder.FeeStructOutput[],
    erc721Token: string,
    erc721TokenId: bigint,
    erc721TokenProperties: LibNFTOrder.PropertyStructOutput[]
  ];
  export interface OutputObject {
    direction: bigint;
    maker: string;
    taker: string;
    expiry: bigint;
    nonce: bigint;
    erc20Token: string;
    erc20TokenAmount: bigint;
    fees: LibNFTOrder.FeeStructOutput[];
    erc721Token: string;
    erc721TokenId: bigint;
    erc721TokenProperties: LibNFTOrder.PropertyStructOutput[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LimitOrderFilledEvent {
  export type InputTuple = [
    orderHash: BytesLike,
    maker: AddressLike,
    taker: AddressLike,
    feeRecipient: AddressLike,
    makerToken: AddressLike,
    takerToken: AddressLike,
    takerTokenFilledAmount: BigNumberish,
    makerTokenFilledAmount: BigNumberish,
    takerTokenFeeFilledAmount: BigNumberish,
    protocolFeePaid: BigNumberish,
    pool: BytesLike
  ];
  export type OutputTuple = [
    orderHash: string,
    maker: string,
    taker: string,
    feeRecipient: string,
    makerToken: string,
    takerToken: string,
    takerTokenFilledAmount: bigint,
    makerTokenFilledAmount: bigint,
    takerTokenFeeFilledAmount: bigint,
    protocolFeePaid: bigint,
    pool: string
  ];
  export interface OutputObject {
    orderHash: string;
    maker: string;
    taker: string;
    feeRecipient: string;
    makerToken: string;
    takerToken: string;
    takerTokenFilledAmount: bigint;
    makerTokenFilledAmount: bigint;
    takerTokenFeeFilledAmount: bigint;
    protocolFeePaid: bigint;
    pool: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidityProviderSwapEvent {
  export type InputTuple = [
    inputToken: AddressLike,
    outputToken: AddressLike,
    inputTokenAmount: BigNumberish,
    outputTokenAmount: BigNumberish,
    provider: AddressLike,
    recipient: AddressLike
  ];
  export type OutputTuple = [
    inputToken: string,
    outputToken: string,
    inputTokenAmount: bigint,
    outputTokenAmount: bigint,
    provider: string,
    recipient: string
  ];
  export interface OutputObject {
    inputToken: string;
    outputToken: string;
    inputTokenAmount: bigint;
    outputTokenAmount: bigint;
    provider: string;
    recipient: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MetaTransactionExecutedEvent {
  export type InputTuple = [
    hash: BytesLike,
    selector: BytesLike,
    signer: AddressLike,
    sender: AddressLike
  ];
  export type OutputTuple = [
    hash: string,
    selector: string,
    signer: string,
    sender: string
  ];
  export interface OutputObject {
    hash: string;
    selector: string;
    signer: string;
    sender: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MetaTransactionExecutedV2Event {
  export type InputTuple = [
    hash: BytesLike,
    selector: BytesLike,
    signer: AddressLike,
    sender: AddressLike
  ];
  export type OutputTuple = [
    hash: string,
    selector: string,
    signer: string,
    sender: string
  ];
  export interface OutputObject {
    hash: string;
    selector: string;
    signer: string;
    sender: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MigratedEvent {
  export type InputTuple = [
    caller: AddressLike,
    migrator: AddressLike,
    newOwner: AddressLike
  ];
  export type OutputTuple = [
    caller: string,
    migrator: string,
    newOwner: string
  ];
  export interface OutputObject {
    caller: string;
    migrator: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderCancelledEvent {
  export type InputTuple = [orderHash: BytesLike, maker: AddressLike];
  export type OutputTuple = [orderHash: string, maker: string];
  export interface OutputObject {
    orderHash: string;
    maker: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderSignerRegisteredEvent {
  export type InputTuple = [
    maker: AddressLike,
    signer: AddressLike,
    allowed: boolean
  ];
  export type OutputTuple = [maker: string, signer: string, allowed: boolean];
  export interface OutputObject {
    maker: string;
    signer: string;
    allowed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OtcOrderFilledEvent {
  export type InputTuple = [
    orderHash: BytesLike,
    maker: AddressLike,
    taker: AddressLike,
    makerToken: AddressLike,
    takerToken: AddressLike,
    makerTokenFilledAmount: BigNumberish,
    takerTokenFilledAmount: BigNumberish
  ];
  export type OutputTuple = [
    orderHash: string,
    maker: string,
    taker: string,
    makerToken: string,
    takerToken: string,
    makerTokenFilledAmount: bigint,
    takerTokenFilledAmount: bigint
  ];
  export interface OutputObject {
    orderHash: string;
    maker: string;
    taker: string;
    makerToken: string;
    takerToken: string;
    makerTokenFilledAmount: bigint;
    takerTokenFilledAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PairCancelledLimitOrdersEvent {
  export type InputTuple = [
    maker: AddressLike,
    makerToken: AddressLike,
    takerToken: AddressLike,
    minValidSalt: BigNumberish
  ];
  export type OutputTuple = [
    maker: string,
    makerToken: string,
    takerToken: string,
    minValidSalt: bigint
  ];
  export interface OutputObject {
    maker: string;
    makerToken: string;
    takerToken: string;
    minValidSalt: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PairCancelledRfqOrdersEvent {
  export type InputTuple = [
    maker: AddressLike,
    makerToken: AddressLike,
    takerToken: AddressLike,
    minValidSalt: BigNumberish
  ];
  export type OutputTuple = [
    maker: string,
    makerToken: string,
    takerToken: string,
    minValidSalt: bigint
  ];
  export interface OutputObject {
    maker: string;
    makerToken: string;
    takerToken: string;
    minValidSalt: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ProxyFunctionUpdatedEvent {
  export type InputTuple = [
    selector: BytesLike,
    oldImpl: AddressLike,
    newImpl: AddressLike
  ];
  export type OutputTuple = [
    selector: string,
    oldImpl: string,
    newImpl: string
  ];
  export interface OutputObject {
    selector: string;
    oldImpl: string;
    newImpl: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace QuoteSignerUpdatedEvent {
  export type InputTuple = [quoteSigner: AddressLike];
  export type OutputTuple = [quoteSigner: string];
  export interface OutputObject {
    quoteSigner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RfqOrderFilledEvent {
  export type InputTuple = [
    orderHash: BytesLike,
    maker: AddressLike,
    taker: AddressLike,
    makerToken: AddressLike,
    takerToken: AddressLike,
    takerTokenFilledAmount: BigNumberish,
    makerTokenFilledAmount: BigNumberish,
    pool: BytesLike
  ];
  export type OutputTuple = [
    orderHash: string,
    maker: string,
    taker: string,
    makerToken: string,
    takerToken: string,
    takerTokenFilledAmount: bigint,
    makerTokenFilledAmount: bigint,
    pool: string
  ];
  export interface OutputObject {
    orderHash: string;
    maker: string;
    taker: string;
    makerToken: string;
    takerToken: string;
    takerTokenFilledAmount: bigint;
    makerTokenFilledAmount: bigint;
    pool: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RfqOrderOriginsAllowedEvent {
  export type InputTuple = [
    origin: AddressLike,
    addrs: AddressLike[],
    allowed: boolean
  ];
  export type OutputTuple = [origin: string, addrs: string[], allowed: boolean];
  export interface OutputObject {
    origin: string;
    addrs: string[];
    allowed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransformedERC20Event {
  export type InputTuple = [
    taker: AddressLike,
    inputToken: AddressLike,
    outputToken: AddressLike,
    inputTokenAmount: BigNumberish,
    outputTokenAmount: BigNumberish
  ];
  export type OutputTuple = [
    taker: string,
    inputToken: string,
    outputToken: string,
    inputTokenAmount: bigint,
    outputTokenAmount: bigint
  ];
  export interface OutputObject {
    taker: string;
    inputToken: string;
    outputToken: string;
    inputTokenAmount: bigint;
    outputTokenAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransformerDeployerUpdatedEvent {
  export type InputTuple = [transformerDeployer: AddressLike];
  export type OutputTuple = [transformerDeployer: string];
  export interface OutputObject {
    transformerDeployer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IZeroEx extends BaseContract {
  connect(runner?: ContractRunner | null): IZeroEx;
  waitForDeployment(): Promise<this>;

  interface: IZeroExInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  _fillLimitOrder: TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish,
      taker: AddressLike,
      sender: AddressLike
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "payable"
  >;

  _fillOtcOrder: TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish,
      taker: AddressLike,
      useSelfBalance: boolean,
      recipient: AddressLike
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;

  _fillRfqOrder: TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish,
      taker: AddressLike,
      useSelfBalance: boolean,
      recipient: AddressLike
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;

  _multiplexBatchSell: TypedContractMethod<
    [
      params: IMultiplexFeature.BatchSellParamsStruct,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  _multiplexMultiHopSell: TypedContractMethod<
    [
      params: IMultiplexFeature.MultiHopSellParamsStruct,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  _sellHeldTokenForTokenToUniswapV3: TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  _sellTokenForTokenToUniswapV3: TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike,
      payer: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  _transformERC20: TypedContractMethod<
    [args: ITransformERC20Feature.TransformERC20ArgsStruct],
    [bigint],
    "payable"
  >;

  batchBuyERC1155s: TypedContractMethod<
    [
      sellOrders: LibNFTOrder.ERC1155OrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      erc1155TokenAmounts: BigNumberish[],
      callbackData: BytesLike[],
      revertIfIncomplete: boolean
    ],
    [boolean[]],
    "payable"
  >;

  batchBuyERC721s: TypedContractMethod<
    [
      sellOrders: LibNFTOrder.ERC721OrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      callbackData: BytesLike[],
      revertIfIncomplete: boolean
    ],
    [boolean[]],
    "payable"
  >;

  batchCancelERC1155Orders: TypedContractMethod<
    [orderNonces: BigNumberish[]],
    [void],
    "nonpayable"
  >;

  batchCancelERC721Orders: TypedContractMethod<
    [orderNonces: BigNumberish[]],
    [void],
    "nonpayable"
  >;

  batchCancelLimitOrders: TypedContractMethod<
    [orders: LibNativeOrder.LimitOrderStruct[]],
    [void],
    "nonpayable"
  >;

  batchCancelPairLimitOrders: TypedContractMethod<
    [
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  batchCancelPairLimitOrdersWithSigner: TypedContractMethod<
    [
      maker: AddressLike,
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  batchCancelPairRfqOrders: TypedContractMethod<
    [
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  batchCancelPairRfqOrdersWithSigner: TypedContractMethod<
    [
      maker: AddressLike,
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  batchCancelRfqOrders: TypedContractMethod<
    [orders: LibNativeOrder.RfqOrderStruct[]],
    [void],
    "nonpayable"
  >;

  batchExecuteMetaTransactions: TypedContractMethod<
    [
      mtxs: IMetaTransactionsFeature.MetaTransactionDataStruct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [string[]],
    "payable"
  >;

  batchExecuteMetaTransactionsV2: TypedContractMethod<
    [
      mtxs: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [string[]],
    "nonpayable"
  >;

  batchFillLimitOrders: TypedContractMethod<
    [
      orders: LibNativeOrder.LimitOrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean
    ],
    [
      [bigint[], bigint[]] & {
        takerTokenFilledAmounts: bigint[];
        makerTokenFilledAmounts: bigint[];
      }
    ],
    "payable"
  >;

  batchFillRfqOrders: TypedContractMethod<
    [
      orders: LibNativeOrder.RfqOrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean
    ],
    [
      [bigint[], bigint[]] & {
        takerTokenFilledAmounts: bigint[];
        makerTokenFilledAmounts: bigint[];
      }
    ],
    "nonpayable"
  >;

  batchFillTakerSignedOtcOrders: TypedContractMethod<
    [
      orders: LibNativeOrder.OtcOrderStruct[],
      makerSignatures: LibSignature.SignatureStruct[],
      takerSignatures: LibSignature.SignatureStruct[],
      unwrapWeth: boolean[]
    ],
    [boolean[]],
    "nonpayable"
  >;

  batchGetLimitOrderRelevantStates: TypedContractMethod<
    [
      orders: LibNativeOrder.LimitOrderStruct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput[], bigint[], boolean[]] & {
        orderInfos: LibNativeOrder.OrderInfoStructOutput[];
        actualFillableTakerTokenAmounts: bigint[];
        isSignatureValids: boolean[];
      }
    ],
    "view"
  >;

  batchGetRfqOrderRelevantStates: TypedContractMethod<
    [
      orders: LibNativeOrder.RfqOrderStruct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput[], bigint[], boolean[]] & {
        orderInfos: LibNativeOrder.OrderInfoStructOutput[];
        actualFillableTakerTokenAmounts: bigint[];
        isSignatureValids: boolean[];
      }
    ],
    "view"
  >;

  batchMatchERC721Orders: TypedContractMethod<
    [
      sellOrders: LibNFTOrder.ERC721OrderStruct[],
      buyOrders: LibNFTOrder.ERC721OrderStruct[],
      sellOrderSignatures: LibSignature.SignatureStruct[],
      buyOrderSignatures: LibSignature.SignatureStruct[]
    ],
    [[bigint[], boolean[]] & { profits: bigint[]; successes: boolean[] }],
    "nonpayable"
  >;

  buyERC1155: TypedContractMethod<
    [
      sellOrder: LibNFTOrder.ERC1155OrderStruct,
      signature: LibSignature.SignatureStruct,
      erc1155BuyAmount: BigNumberish,
      callbackData: BytesLike
    ],
    [void],
    "payable"
  >;

  buyERC721: TypedContractMethod<
    [
      sellOrder: LibNFTOrder.ERC721OrderStruct,
      signature: LibSignature.SignatureStruct,
      callbackData: BytesLike
    ],
    [void],
    "payable"
  >;

  cancelERC1155Order: TypedContractMethod<
    [orderNonce: BigNumberish],
    [void],
    "nonpayable"
  >;

  cancelERC721Order: TypedContractMethod<
    [orderNonce: BigNumberish],
    [void],
    "nonpayable"
  >;

  cancelLimitOrder: TypedContractMethod<
    [order: LibNativeOrder.LimitOrderStruct],
    [void],
    "nonpayable"
  >;

  cancelPairLimitOrders: TypedContractMethod<
    [
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  cancelPairLimitOrdersWithSigner: TypedContractMethod<
    [
      maker: AddressLike,
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  cancelPairRfqOrders: TypedContractMethod<
    [
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  cancelPairRfqOrdersWithSigner: TypedContractMethod<
    [
      maker: AddressLike,
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  cancelRfqOrder: TypedContractMethod<
    [order: LibNativeOrder.RfqOrderStruct],
    [void],
    "nonpayable"
  >;

  createTransformWallet: TypedContractMethod<[], [string], "nonpayable">;

  executeMetaTransaction: TypedContractMethod<
    [
      mtx: IMetaTransactionsFeature.MetaTransactionDataStruct,
      signature: LibSignature.SignatureStruct
    ],
    [string],
    "payable"
  >;

  executeMetaTransactionV2: TypedContractMethod<
    [
      mtx: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct,
      signature: LibSignature.SignatureStruct
    ],
    [string],
    "nonpayable"
  >;

  extend: TypedContractMethod<
    [selector: BytesLike, impl: AddressLike],
    [void],
    "nonpayable"
  >;

  fillLimitOrder: TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "payable"
  >;

  fillOrKillLimitOrder: TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  fillOrKillRfqOrder: TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  fillOtcOrder: TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;

  fillOtcOrderForEth: TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;

  fillOtcOrderWithEth: TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "payable"
  >;

  fillRfqOrder: TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;

  fillTakerSignedOtcOrder: TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerSignature: LibSignature.SignatureStruct
    ],
    [void],
    "nonpayable"
  >;

  fillTakerSignedOtcOrderForEth: TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerSignature: LibSignature.SignatureStruct
    ],
    [void],
    "nonpayable"
  >;

  getERC1155OrderHash: TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct],
    [string],
    "view"
  >;

  getERC1155OrderInfo: TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct],
    [LibNFTOrder.OrderInfoStructOutput],
    "view"
  >;

  getERC721OrderHash: TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct],
    [string],
    "view"
  >;

  getERC721OrderStatus: TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct],
    [bigint],
    "view"
  >;

  getERC721OrderStatusBitVector: TypedContractMethod<
    [maker: AddressLike, nonceRange: BigNumberish],
    [bigint],
    "view"
  >;

  getLimitOrderHash: TypedContractMethod<
    [order: LibNativeOrder.LimitOrderStruct],
    [string],
    "view"
  >;

  getLimitOrderInfo: TypedContractMethod<
    [order: LibNativeOrder.LimitOrderStruct],
    [LibNativeOrder.OrderInfoStructOutput],
    "view"
  >;

  getLimitOrderRelevantState: TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput, bigint, boolean] & {
        orderInfo: LibNativeOrder.OrderInfoStructOutput;
        actualFillableTakerTokenAmount: bigint;
        isSignatureValid: boolean;
      }
    ],
    "view"
  >;

  getMetaTransactionExecutedBlock: TypedContractMethod<
    [mtx: IMetaTransactionsFeature.MetaTransactionDataStruct],
    [bigint],
    "view"
  >;

  getMetaTransactionHash: TypedContractMethod<
    [mtx: IMetaTransactionsFeature.MetaTransactionDataStruct],
    [string],
    "view"
  >;

  getMetaTransactionHashExecutedBlock: TypedContractMethod<
    [mtxHash: BytesLike],
    [bigint],
    "view"
  >;

  getMetaTransactionV2ExecutedBlock: TypedContractMethod<
    [mtx: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct],
    [bigint],
    "view"
  >;

  getMetaTransactionV2Hash: TypedContractMethod<
    [mtx: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct],
    [string],
    "view"
  >;

  getMetaTransactionV2HashExecutedBlock: TypedContractMethod<
    [mtxHash: BytesLike],
    [bigint],
    "view"
  >;

  getOtcOrderHash: TypedContractMethod<
    [order: LibNativeOrder.OtcOrderStruct],
    [string],
    "view"
  >;

  getOtcOrderInfo: TypedContractMethod<
    [order: LibNativeOrder.OtcOrderStruct],
    [LibNativeOrder.OtcOrderInfoStructOutput],
    "view"
  >;

  getProtocolFeeMultiplier: TypedContractMethod<[], [bigint], "view">;

  getQuoteSigner: TypedContractMethod<[], [string], "view">;

  getRfqOrderHash: TypedContractMethod<
    [order: LibNativeOrder.RfqOrderStruct],
    [string],
    "view"
  >;

  getRfqOrderInfo: TypedContractMethod<
    [order: LibNativeOrder.RfqOrderStruct],
    [LibNativeOrder.OrderInfoStructOutput],
    "view"
  >;

  getRfqOrderRelevantState: TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput, bigint, boolean] & {
        orderInfo: LibNativeOrder.OrderInfoStructOutput;
        actualFillableTakerTokenAmount: bigint;
        isSignatureValid: boolean;
      }
    ],
    "view"
  >;

  getRollbackEntryAtIndex: TypedContractMethod<
    [selector: BytesLike, idx: BigNumberish],
    [string],
    "view"
  >;

  getRollbackLength: TypedContractMethod<
    [selector: BytesLike],
    [bigint],
    "view"
  >;

  getTransformWallet: TypedContractMethod<[], [string], "view">;

  getTransformerDeployer: TypedContractMethod<[], [string], "view">;

  isValidOrderSigner: TypedContractMethod<
    [maker: AddressLike, signer: AddressLike],
    [boolean],
    "view"
  >;

  lastOtcTxOriginNonce: TypedContractMethod<
    [txOrigin: AddressLike, nonceBucket: BigNumberish],
    [bigint],
    "view"
  >;

  matchERC721Orders: TypedContractMethod<
    [
      sellOrder: LibNFTOrder.ERC721OrderStruct,
      buyOrder: LibNFTOrder.ERC721OrderStruct,
      sellOrderSignature: LibSignature.SignatureStruct,
      buyOrderSignature: LibSignature.SignatureStruct
    ],
    [bigint],
    "nonpayable"
  >;

  migrate: TypedContractMethod<
    [target: AddressLike, data: BytesLike, newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  multiplexBatchSellEthForToken: TypedContractMethod<
    [
      outputToken: AddressLike,
      calls: IMultiplexFeature.BatchSellSubcallStruct[],
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  multiplexBatchSellTokenForEth: TypedContractMethod<
    [
      inputToken: AddressLike,
      calls: IMultiplexFeature.BatchSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  multiplexBatchSellTokenForToken: TypedContractMethod<
    [
      inputToken: AddressLike,
      outputToken: AddressLike,
      calls: IMultiplexFeature.BatchSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  multiplexMultiHopSellEthForToken: TypedContractMethod<
    [
      tokens: AddressLike[],
      calls: IMultiplexFeature.MultiHopSellSubcallStruct[],
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  multiplexMultiHopSellTokenForEth: TypedContractMethod<
    [
      tokens: AddressLike[],
      calls: IMultiplexFeature.MultiHopSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  multiplexMultiHopSellTokenForToken: TypedContractMethod<
    [
      tokens: AddressLike[],
      calls: IMultiplexFeature.MultiHopSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  onERC1155Received: TypedContractMethod<
    [
      operator: AddressLike,
      from: AddressLike,
      tokenId: BigNumberish,
      value: BigNumberish,
      data: BytesLike
    ],
    [string],
    "nonpayable"
  >;

  onERC721Received: TypedContractMethod<
    [
      operator: AddressLike,
      from: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [string],
    "nonpayable"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  preSignERC1155Order: TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct],
    [void],
    "nonpayable"
  >;

  preSignERC721Order: TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct],
    [void],
    "nonpayable"
  >;

  registerAllowedOrderSigner: TypedContractMethod<
    [signer: AddressLike, allowed: boolean],
    [void],
    "nonpayable"
  >;

  registerAllowedRfqOrigins: TypedContractMethod<
    [origins: AddressLike[], allowed: boolean],
    [void],
    "nonpayable"
  >;

  rollback: TypedContractMethod<
    [selector: BytesLike, targetImpl: AddressLike],
    [void],
    "nonpayable"
  >;

  sellERC1155: TypedContractMethod<
    [
      buyOrder: LibNFTOrder.ERC1155OrderStruct,
      signature: LibSignature.SignatureStruct,
      erc1155TokenId: BigNumberish,
      erc1155SellAmount: BigNumberish,
      unwrapNativeToken: boolean,
      callbackData: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  sellERC721: TypedContractMethod<
    [
      buyOrder: LibNFTOrder.ERC721OrderStruct,
      signature: LibSignature.SignatureStruct,
      erc721TokenId: BigNumberish,
      unwrapNativeToken: boolean,
      callbackData: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  sellEthForTokenToUniswapV3: TypedContractMethod<
    [
      encodedPath: BytesLike,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "payable"
  >;

  sellToLiquidityProvider: TypedContractMethod<
    [
      inputToken: AddressLike,
      outputToken: AddressLike,
      provider: AddressLike,
      recipient: AddressLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike
    ],
    [bigint],
    "payable"
  >;

  sellToPancakeSwap: TypedContractMethod<
    [
      tokens: AddressLike[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  sellToUniswap: TypedContractMethod<
    [
      tokens: AddressLike[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean
    ],
    [bigint],
    "payable"
  >;

  sellTokenForEthToUniswapV3: TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  sellTokenForTokenToUniswapV3: TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  setQuoteSigner: TypedContractMethod<
    [quoteSigner: AddressLike],
    [void],
    "nonpayable"
  >;

  setTransformerDeployer: TypedContractMethod<
    [transformerDeployer: AddressLike],
    [void],
    "nonpayable"
  >;

  supportInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  transferProtocolFeesForPools: TypedContractMethod<
    [poolIds: BytesLike[]],
    [void],
    "nonpayable"
  >;

  transferTrappedTokensTo: TypedContractMethod<
    [erc20: AddressLike, amountOut: BigNumberish, recipientWallet: AddressLike],
    [void],
    "nonpayable"
  >;

  transformERC20: TypedContractMethod<
    [
      inputToken: AddressLike,
      outputToken: AddressLike,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: ITransformERC20Feature.TransformationStruct[]
    ],
    [bigint],
    "payable"
  >;

  uniswapV3SwapCallback: TypedContractMethod<
    [amount0Delta: BigNumberish, amount1Delta: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;

  validateERC1155OrderProperties: TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct, erc1155TokenId: BigNumberish],
    [void],
    "view"
  >;

  validateERC1155OrderSignature: TypedContractMethod<
    [
      order: LibNFTOrder.ERC1155OrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [void],
    "view"
  >;

  validateERC721OrderProperties: TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct, erc721TokenId: BigNumberish],
    [void],
    "view"
  >;

  validateERC721OrderSignature: TypedContractMethod<
    [
      order: LibNFTOrder.ERC721OrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [void],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "_fillLimitOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish,
      taker: AddressLike,
      sender: AddressLike
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "payable"
  >;
  getFunction(
    nameOrSignature: "_fillOtcOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish,
      taker: AddressLike,
      useSelfBalance: boolean,
      recipient: AddressLike
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "_fillRfqOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish,
      taker: AddressLike,
      useSelfBalance: boolean,
      recipient: AddressLike
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "_multiplexBatchSell"
  ): TypedContractMethod<
    [
      params: IMultiplexFeature.BatchSellParamsStruct,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "_multiplexMultiHopSell"
  ): TypedContractMethod<
    [
      params: IMultiplexFeature.MultiHopSellParamsStruct,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "_sellHeldTokenForTokenToUniswapV3"
  ): TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "_sellTokenForTokenToUniswapV3"
  ): TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike,
      payer: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "_transformERC20"
  ): TypedContractMethod<
    [args: ITransformERC20Feature.TransformERC20ArgsStruct],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "batchBuyERC1155s"
  ): TypedContractMethod<
    [
      sellOrders: LibNFTOrder.ERC1155OrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      erc1155TokenAmounts: BigNumberish[],
      callbackData: BytesLike[],
      revertIfIncomplete: boolean
    ],
    [boolean[]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "batchBuyERC721s"
  ): TypedContractMethod<
    [
      sellOrders: LibNFTOrder.ERC721OrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      callbackData: BytesLike[],
      revertIfIncomplete: boolean
    ],
    [boolean[]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "batchCancelERC1155Orders"
  ): TypedContractMethod<[orderNonces: BigNumberish[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "batchCancelERC721Orders"
  ): TypedContractMethod<[orderNonces: BigNumberish[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "batchCancelLimitOrders"
  ): TypedContractMethod<
    [orders: LibNativeOrder.LimitOrderStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchCancelPairLimitOrders"
  ): TypedContractMethod<
    [
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchCancelPairLimitOrdersWithSigner"
  ): TypedContractMethod<
    [
      maker: AddressLike,
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchCancelPairRfqOrders"
  ): TypedContractMethod<
    [
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchCancelPairRfqOrdersWithSigner"
  ): TypedContractMethod<
    [
      maker: AddressLike,
      makerTokens: AddressLike[],
      takerTokens: AddressLike[],
      minValidSalts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchCancelRfqOrders"
  ): TypedContractMethod<
    [orders: LibNativeOrder.RfqOrderStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchExecuteMetaTransactions"
  ): TypedContractMethod<
    [
      mtxs: IMetaTransactionsFeature.MetaTransactionDataStruct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [string[]],
    "payable"
  >;
  getFunction(
    nameOrSignature: "batchExecuteMetaTransactionsV2"
  ): TypedContractMethod<
    [
      mtxs: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [string[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchFillLimitOrders"
  ): TypedContractMethod<
    [
      orders: LibNativeOrder.LimitOrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean
    ],
    [
      [bigint[], bigint[]] & {
        takerTokenFilledAmounts: bigint[];
        makerTokenFilledAmounts: bigint[];
      }
    ],
    "payable"
  >;
  getFunction(
    nameOrSignature: "batchFillRfqOrders"
  ): TypedContractMethod<
    [
      orders: LibNativeOrder.RfqOrderStruct[],
      signatures: LibSignature.SignatureStruct[],
      takerTokenFillAmounts: BigNumberish[],
      revertIfIncomplete: boolean
    ],
    [
      [bigint[], bigint[]] & {
        takerTokenFilledAmounts: bigint[];
        makerTokenFilledAmounts: bigint[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchFillTakerSignedOtcOrders"
  ): TypedContractMethod<
    [
      orders: LibNativeOrder.OtcOrderStruct[],
      makerSignatures: LibSignature.SignatureStruct[],
      takerSignatures: LibSignature.SignatureStruct[],
      unwrapWeth: boolean[]
    ],
    [boolean[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchGetLimitOrderRelevantStates"
  ): TypedContractMethod<
    [
      orders: LibNativeOrder.LimitOrderStruct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput[], bigint[], boolean[]] & {
        orderInfos: LibNativeOrder.OrderInfoStructOutput[];
        actualFillableTakerTokenAmounts: bigint[];
        isSignatureValids: boolean[];
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "batchGetRfqOrderRelevantStates"
  ): TypedContractMethod<
    [
      orders: LibNativeOrder.RfqOrderStruct[],
      signatures: LibSignature.SignatureStruct[]
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput[], bigint[], boolean[]] & {
        orderInfos: LibNativeOrder.OrderInfoStructOutput[];
        actualFillableTakerTokenAmounts: bigint[];
        isSignatureValids: boolean[];
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "batchMatchERC721Orders"
  ): TypedContractMethod<
    [
      sellOrders: LibNFTOrder.ERC721OrderStruct[],
      buyOrders: LibNFTOrder.ERC721OrderStruct[],
      sellOrderSignatures: LibSignature.SignatureStruct[],
      buyOrderSignatures: LibSignature.SignatureStruct[]
    ],
    [[bigint[], boolean[]] & { profits: bigint[]; successes: boolean[] }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "buyERC1155"
  ): TypedContractMethod<
    [
      sellOrder: LibNFTOrder.ERC1155OrderStruct,
      signature: LibSignature.SignatureStruct,
      erc1155BuyAmount: BigNumberish,
      callbackData: BytesLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyERC721"
  ): TypedContractMethod<
    [
      sellOrder: LibNFTOrder.ERC721OrderStruct,
      signature: LibSignature.SignatureStruct,
      callbackData: BytesLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "cancelERC1155Order"
  ): TypedContractMethod<[orderNonce: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "cancelERC721Order"
  ): TypedContractMethod<[orderNonce: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "cancelLimitOrder"
  ): TypedContractMethod<
    [order: LibNativeOrder.LimitOrderStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelPairLimitOrders"
  ): TypedContractMethod<
    [
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelPairLimitOrdersWithSigner"
  ): TypedContractMethod<
    [
      maker: AddressLike,
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelPairRfqOrders"
  ): TypedContractMethod<
    [
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelPairRfqOrdersWithSigner"
  ): TypedContractMethod<
    [
      maker: AddressLike,
      makerToken: AddressLike,
      takerToken: AddressLike,
      minValidSalt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelRfqOrder"
  ): TypedContractMethod<
    [order: LibNativeOrder.RfqOrderStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createTransformWallet"
  ): TypedContractMethod<[], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "executeMetaTransaction"
  ): TypedContractMethod<
    [
      mtx: IMetaTransactionsFeature.MetaTransactionDataStruct,
      signature: LibSignature.SignatureStruct
    ],
    [string],
    "payable"
  >;
  getFunction(
    nameOrSignature: "executeMetaTransactionV2"
  ): TypedContractMethod<
    [
      mtx: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct,
      signature: LibSignature.SignatureStruct
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "extend"
  ): TypedContractMethod<
    [selector: BytesLike, impl: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fillLimitOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "payable"
  >;
  getFunction(
    nameOrSignature: "fillOrKillLimitOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "fillOrKillRfqOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fillOtcOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fillOtcOrderForEth"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fillOtcOrderWithEth"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "payable"
  >;
  getFunction(
    nameOrSignature: "fillRfqOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct,
      takerTokenFillAmount: BigNumberish
    ],
    [
      [bigint, bigint] & {
        takerTokenFilledAmount: bigint;
        makerTokenFilledAmount: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fillTakerSignedOtcOrder"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerSignature: LibSignature.SignatureStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fillTakerSignedOtcOrderForEth"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.OtcOrderStruct,
      makerSignature: LibSignature.SignatureStruct,
      takerSignature: LibSignature.SignatureStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getERC1155OrderHash"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getERC1155OrderInfo"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct],
    [LibNFTOrder.OrderInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getERC721OrderHash"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getERC721OrderStatus"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getERC721OrderStatusBitVector"
  ): TypedContractMethod<
    [maker: AddressLike, nonceRange: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getLimitOrderHash"
  ): TypedContractMethod<
    [order: LibNativeOrder.LimitOrderStruct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getLimitOrderInfo"
  ): TypedContractMethod<
    [order: LibNativeOrder.LimitOrderStruct],
    [LibNativeOrder.OrderInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getLimitOrderRelevantState"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.LimitOrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput, bigint, boolean] & {
        orderInfo: LibNativeOrder.OrderInfoStructOutput;
        actualFillableTakerTokenAmount: bigint;
        isSignatureValid: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMetaTransactionExecutedBlock"
  ): TypedContractMethod<
    [mtx: IMetaTransactionsFeature.MetaTransactionDataStruct],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMetaTransactionHash"
  ): TypedContractMethod<
    [mtx: IMetaTransactionsFeature.MetaTransactionDataStruct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMetaTransactionHashExecutedBlock"
  ): TypedContractMethod<[mtxHash: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getMetaTransactionV2ExecutedBlock"
  ): TypedContractMethod<
    [mtx: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMetaTransactionV2Hash"
  ): TypedContractMethod<
    [mtx: IMetaTransactionsFeatureV2.MetaTransactionDataV2Struct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMetaTransactionV2HashExecutedBlock"
  ): TypedContractMethod<[mtxHash: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getOtcOrderHash"
  ): TypedContractMethod<
    [order: LibNativeOrder.OtcOrderStruct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOtcOrderInfo"
  ): TypedContractMethod<
    [order: LibNativeOrder.OtcOrderStruct],
    [LibNativeOrder.OtcOrderInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getProtocolFeeMultiplier"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getQuoteSigner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getRfqOrderHash"
  ): TypedContractMethod<
    [order: LibNativeOrder.RfqOrderStruct],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRfqOrderInfo"
  ): TypedContractMethod<
    [order: LibNativeOrder.RfqOrderStruct],
    [LibNativeOrder.OrderInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRfqOrderRelevantState"
  ): TypedContractMethod<
    [
      order: LibNativeOrder.RfqOrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [
      [LibNativeOrder.OrderInfoStructOutput, bigint, boolean] & {
        orderInfo: LibNativeOrder.OrderInfoStructOutput;
        actualFillableTakerTokenAmount: bigint;
        isSignatureValid: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRollbackEntryAtIndex"
  ): TypedContractMethod<
    [selector: BytesLike, idx: BigNumberish],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRollbackLength"
  ): TypedContractMethod<[selector: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getTransformWallet"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getTransformerDeployer"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "isValidOrderSigner"
  ): TypedContractMethod<
    [maker: AddressLike, signer: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "lastOtcTxOriginNonce"
  ): TypedContractMethod<
    [txOrigin: AddressLike, nonceBucket: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "matchERC721Orders"
  ): TypedContractMethod<
    [
      sellOrder: LibNFTOrder.ERC721OrderStruct,
      buyOrder: LibNFTOrder.ERC721OrderStruct,
      sellOrderSignature: LibSignature.SignatureStruct,
      buyOrderSignature: LibSignature.SignatureStruct
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "migrate"
  ): TypedContractMethod<
    [target: AddressLike, data: BytesLike, newOwner: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "multiplexBatchSellEthForToken"
  ): TypedContractMethod<
    [
      outputToken: AddressLike,
      calls: IMultiplexFeature.BatchSellSubcallStruct[],
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "multiplexBatchSellTokenForEth"
  ): TypedContractMethod<
    [
      inputToken: AddressLike,
      calls: IMultiplexFeature.BatchSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "multiplexBatchSellTokenForToken"
  ): TypedContractMethod<
    [
      inputToken: AddressLike,
      outputToken: AddressLike,
      calls: IMultiplexFeature.BatchSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "multiplexMultiHopSellEthForToken"
  ): TypedContractMethod<
    [
      tokens: AddressLike[],
      calls: IMultiplexFeature.MultiHopSellSubcallStruct[],
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "multiplexMultiHopSellTokenForEth"
  ): TypedContractMethod<
    [
      tokens: AddressLike[],
      calls: IMultiplexFeature.MultiHopSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "multiplexMultiHopSellTokenForToken"
  ): TypedContractMethod<
    [
      tokens: AddressLike[],
      calls: IMultiplexFeature.MultiHopSellSubcallStruct[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "onERC1155Received"
  ): TypedContractMethod<
    [
      operator: AddressLike,
      from: AddressLike,
      tokenId: BigNumberish,
      value: BigNumberish,
      data: BytesLike
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "onERC721Received"
  ): TypedContractMethod<
    [
      operator: AddressLike,
      from: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "preSignERC1155Order"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "preSignERC721Order"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "registerAllowedOrderSigner"
  ): TypedContractMethod<
    [signer: AddressLike, allowed: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "registerAllowedRfqOrigins"
  ): TypedContractMethod<
    [origins: AddressLike[], allowed: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "rollback"
  ): TypedContractMethod<
    [selector: BytesLike, targetImpl: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellERC1155"
  ): TypedContractMethod<
    [
      buyOrder: LibNFTOrder.ERC1155OrderStruct,
      signature: LibSignature.SignatureStruct,
      erc1155TokenId: BigNumberish,
      erc1155SellAmount: BigNumberish,
      unwrapNativeToken: boolean,
      callbackData: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellERC721"
  ): TypedContractMethod<
    [
      buyOrder: LibNFTOrder.ERC721OrderStruct,
      signature: LibSignature.SignatureStruct,
      erc721TokenId: BigNumberish,
      unwrapNativeToken: boolean,
      callbackData: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellEthForTokenToUniswapV3"
  ): TypedContractMethod<
    [
      encodedPath: BytesLike,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "sellToLiquidityProvider"
  ): TypedContractMethod<
    [
      inputToken: AddressLike,
      outputToken: AddressLike,
      provider: AddressLike,
      recipient: AddressLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      auxiliaryData: BytesLike
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "sellToPancakeSwap"
  ): TypedContractMethod<
    [
      tokens: AddressLike[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      fork: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "sellToUniswap"
  ): TypedContractMethod<
    [
      tokens: AddressLike[],
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      isSushi: boolean
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "sellTokenForEthToUniswapV3"
  ): TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellTokenForTokenToUniswapV3"
  ): TypedContractMethod<
    [
      encodedPath: BytesLike,
      sellAmount: BigNumberish,
      minBuyAmount: BigNumberish,
      recipient: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setQuoteSigner"
  ): TypedContractMethod<[quoteSigner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setTransformerDeployer"
  ): TypedContractMethod<
    [transformerDeployer: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "supportInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferProtocolFeesForPools"
  ): TypedContractMethod<[poolIds: BytesLike[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferTrappedTokensTo"
  ): TypedContractMethod<
    [erc20: AddressLike, amountOut: BigNumberish, recipientWallet: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transformERC20"
  ): TypedContractMethod<
    [
      inputToken: AddressLike,
      outputToken: AddressLike,
      inputTokenAmount: BigNumberish,
      minOutputTokenAmount: BigNumberish,
      transformations: ITransformERC20Feature.TransformationStruct[]
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "uniswapV3SwapCallback"
  ): TypedContractMethod<
    [amount0Delta: BigNumberish, amount1Delta: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "validateERC1155OrderProperties"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC1155OrderStruct, erc1155TokenId: BigNumberish],
    [void],
    "view"
  >;
  getFunction(
    nameOrSignature: "validateERC1155OrderSignature"
  ): TypedContractMethod<
    [
      order: LibNFTOrder.ERC1155OrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [void],
    "view"
  >;
  getFunction(
    nameOrSignature: "validateERC721OrderProperties"
  ): TypedContractMethod<
    [order: LibNFTOrder.ERC721OrderStruct, erc721TokenId: BigNumberish],
    [void],
    "view"
  >;
  getFunction(
    nameOrSignature: "validateERC721OrderSignature"
  ): TypedContractMethod<
    [
      order: LibNFTOrder.ERC721OrderStruct,
      signature: LibSignature.SignatureStruct
    ],
    [void],
    "view"
  >;

  getEvent(
    key: "ERC1155OrderCancelled"
  ): TypedContractEvent<
    ERC1155OrderCancelledEvent.InputTuple,
    ERC1155OrderCancelledEvent.OutputTuple,
    ERC1155OrderCancelledEvent.OutputObject
  >;
  getEvent(
    key: "ERC1155OrderFilled"
  ): TypedContractEvent<
    ERC1155OrderFilledEvent.InputTuple,
    ERC1155OrderFilledEvent.OutputTuple,
    ERC1155OrderFilledEvent.OutputObject
  >;
  getEvent(
    key: "ERC1155OrderPreSigned"
  ): TypedContractEvent<
    ERC1155OrderPreSignedEvent.InputTuple,
    ERC1155OrderPreSignedEvent.OutputTuple,
    ERC1155OrderPreSignedEvent.OutputObject
  >;
  getEvent(
    key: "ERC721OrderCancelled"
  ): TypedContractEvent<
    ERC721OrderCancelledEvent.InputTuple,
    ERC721OrderCancelledEvent.OutputTuple,
    ERC721OrderCancelledEvent.OutputObject
  >;
  getEvent(
    key: "ERC721OrderFilled"
  ): TypedContractEvent<
    ERC721OrderFilledEvent.InputTuple,
    ERC721OrderFilledEvent.OutputTuple,
    ERC721OrderFilledEvent.OutputObject
  >;
  getEvent(
    key: "ERC721OrderPreSigned"
  ): TypedContractEvent<
    ERC721OrderPreSignedEvent.InputTuple,
    ERC721OrderPreSignedEvent.OutputTuple,
    ERC721OrderPreSignedEvent.OutputObject
  >;
  getEvent(
    key: "LimitOrderFilled"
  ): TypedContractEvent<
    LimitOrderFilledEvent.InputTuple,
    LimitOrderFilledEvent.OutputTuple,
    LimitOrderFilledEvent.OutputObject
  >;
  getEvent(
    key: "LiquidityProviderSwap"
  ): TypedContractEvent<
    LiquidityProviderSwapEvent.InputTuple,
    LiquidityProviderSwapEvent.OutputTuple,
    LiquidityProviderSwapEvent.OutputObject
  >;
  getEvent(
    key: "MetaTransactionExecuted"
  ): TypedContractEvent<
    MetaTransactionExecutedEvent.InputTuple,
    MetaTransactionExecutedEvent.OutputTuple,
    MetaTransactionExecutedEvent.OutputObject
  >;
  getEvent(
    key: "MetaTransactionExecutedV2"
  ): TypedContractEvent<
    MetaTransactionExecutedV2Event.InputTuple,
    MetaTransactionExecutedV2Event.OutputTuple,
    MetaTransactionExecutedV2Event.OutputObject
  >;
  getEvent(
    key: "Migrated"
  ): TypedContractEvent<
    MigratedEvent.InputTuple,
    MigratedEvent.OutputTuple,
    MigratedEvent.OutputObject
  >;
  getEvent(
    key: "OrderCancelled"
  ): TypedContractEvent<
    OrderCancelledEvent.InputTuple,
    OrderCancelledEvent.OutputTuple,
    OrderCancelledEvent.OutputObject
  >;
  getEvent(
    key: "OrderSignerRegistered"
  ): TypedContractEvent<
    OrderSignerRegisteredEvent.InputTuple,
    OrderSignerRegisteredEvent.OutputTuple,
    OrderSignerRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "OtcOrderFilled"
  ): TypedContractEvent<
    OtcOrderFilledEvent.InputTuple,
    OtcOrderFilledEvent.OutputTuple,
    OtcOrderFilledEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "PairCancelledLimitOrders"
  ): TypedContractEvent<
    PairCancelledLimitOrdersEvent.InputTuple,
    PairCancelledLimitOrdersEvent.OutputTuple,
    PairCancelledLimitOrdersEvent.OutputObject
  >;
  getEvent(
    key: "PairCancelledRfqOrders"
  ): TypedContractEvent<
    PairCancelledRfqOrdersEvent.InputTuple,
    PairCancelledRfqOrdersEvent.OutputTuple,
    PairCancelledRfqOrdersEvent.OutputObject
  >;
  getEvent(
    key: "ProxyFunctionUpdated"
  ): TypedContractEvent<
    ProxyFunctionUpdatedEvent.InputTuple,
    ProxyFunctionUpdatedEvent.OutputTuple,
    ProxyFunctionUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "QuoteSignerUpdated"
  ): TypedContractEvent<
    QuoteSignerUpdatedEvent.InputTuple,
    QuoteSignerUpdatedEvent.OutputTuple,
    QuoteSignerUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "RfqOrderFilled"
  ): TypedContractEvent<
    RfqOrderFilledEvent.InputTuple,
    RfqOrderFilledEvent.OutputTuple,
    RfqOrderFilledEvent.OutputObject
  >;
  getEvent(
    key: "RfqOrderOriginsAllowed"
  ): TypedContractEvent<
    RfqOrderOriginsAllowedEvent.InputTuple,
    RfqOrderOriginsAllowedEvent.OutputTuple,
    RfqOrderOriginsAllowedEvent.OutputObject
  >;
  getEvent(
    key: "TransformedERC20"
  ): TypedContractEvent<
    TransformedERC20Event.InputTuple,
    TransformedERC20Event.OutputTuple,
    TransformedERC20Event.OutputObject
  >;
  getEvent(
    key: "TransformerDeployerUpdated"
  ): TypedContractEvent<
    TransformerDeployerUpdatedEvent.InputTuple,
    TransformerDeployerUpdatedEvent.OutputTuple,
    TransformerDeployerUpdatedEvent.OutputObject
  >;

  filters: {
    "ERC1155OrderCancelled(address,uint256)": TypedContractEvent<
      ERC1155OrderCancelledEvent.InputTuple,
      ERC1155OrderCancelledEvent.OutputTuple,
      ERC1155OrderCancelledEvent.OutputObject
    >;
    ERC1155OrderCancelled: TypedContractEvent<
      ERC1155OrderCancelledEvent.InputTuple,
      ERC1155OrderCancelledEvent.OutputTuple,
      ERC1155OrderCancelledEvent.OutputObject
    >;

    "ERC1155OrderFilled(uint8,address,address,uint256,address,uint256,address,uint256,uint128,address)": TypedContractEvent<
      ERC1155OrderFilledEvent.InputTuple,
      ERC1155OrderFilledEvent.OutputTuple,
      ERC1155OrderFilledEvent.OutputObject
    >;
    ERC1155OrderFilled: TypedContractEvent<
      ERC1155OrderFilledEvent.InputTuple,
      ERC1155OrderFilledEvent.OutputTuple,
      ERC1155OrderFilledEvent.OutputObject
    >;

    "ERC1155OrderPreSigned(uint8,address,address,uint256,uint256,address,uint256,tuple[],address,uint256,tuple[],uint128)": TypedContractEvent<
      ERC1155OrderPreSignedEvent.InputTuple,
      ERC1155OrderPreSignedEvent.OutputTuple,
      ERC1155OrderPreSignedEvent.OutputObject
    >;
    ERC1155OrderPreSigned: TypedContractEvent<
      ERC1155OrderPreSignedEvent.InputTuple,
      ERC1155OrderPreSignedEvent.OutputTuple,
      ERC1155OrderPreSignedEvent.OutputObject
    >;

    "ERC721OrderCancelled(address,uint256)": TypedContractEvent<
      ERC721OrderCancelledEvent.InputTuple,
      ERC721OrderCancelledEvent.OutputTuple,
      ERC721OrderCancelledEvent.OutputObject
    >;
    ERC721OrderCancelled: TypedContractEvent<
      ERC721OrderCancelledEvent.InputTuple,
      ERC721OrderCancelledEvent.OutputTuple,
      ERC721OrderCancelledEvent.OutputObject
    >;

    "ERC721OrderFilled(uint8,address,address,uint256,address,uint256,address,uint256,address)": TypedContractEvent<
      ERC721OrderFilledEvent.InputTuple,
      ERC721OrderFilledEvent.OutputTuple,
      ERC721OrderFilledEvent.OutputObject
    >;
    ERC721OrderFilled: TypedContractEvent<
      ERC721OrderFilledEvent.InputTuple,
      ERC721OrderFilledEvent.OutputTuple,
      ERC721OrderFilledEvent.OutputObject
    >;

    "ERC721OrderPreSigned(uint8,address,address,uint256,uint256,address,uint256,tuple[],address,uint256,tuple[])": TypedContractEvent<
      ERC721OrderPreSignedEvent.InputTuple,
      ERC721OrderPreSignedEvent.OutputTuple,
      ERC721OrderPreSignedEvent.OutputObject
    >;
    ERC721OrderPreSigned: TypedContractEvent<
      ERC721OrderPreSignedEvent.InputTuple,
      ERC721OrderPreSignedEvent.OutputTuple,
      ERC721OrderPreSignedEvent.OutputObject
    >;

    "LimitOrderFilled(bytes32,address,address,address,address,address,uint128,uint128,uint128,uint256,bytes32)": TypedContractEvent<
      LimitOrderFilledEvent.InputTuple,
      LimitOrderFilledEvent.OutputTuple,
      LimitOrderFilledEvent.OutputObject
    >;
    LimitOrderFilled: TypedContractEvent<
      LimitOrderFilledEvent.InputTuple,
      LimitOrderFilledEvent.OutputTuple,
      LimitOrderFilledEvent.OutputObject
    >;

    "LiquidityProviderSwap(address,address,uint256,uint256,address,address)": TypedContractEvent<
      LiquidityProviderSwapEvent.InputTuple,
      LiquidityProviderSwapEvent.OutputTuple,
      LiquidityProviderSwapEvent.OutputObject
    >;
    LiquidityProviderSwap: TypedContractEvent<
      LiquidityProviderSwapEvent.InputTuple,
      LiquidityProviderSwapEvent.OutputTuple,
      LiquidityProviderSwapEvent.OutputObject
    >;

    "MetaTransactionExecuted(bytes32,bytes4,address,address)": TypedContractEvent<
      MetaTransactionExecutedEvent.InputTuple,
      MetaTransactionExecutedEvent.OutputTuple,
      MetaTransactionExecutedEvent.OutputObject
    >;
    MetaTransactionExecuted: TypedContractEvent<
      MetaTransactionExecutedEvent.InputTuple,
      MetaTransactionExecutedEvent.OutputTuple,
      MetaTransactionExecutedEvent.OutputObject
    >;

    "MetaTransactionExecutedV2(bytes32,bytes4,address,address)": TypedContractEvent<
      MetaTransactionExecutedV2Event.InputTuple,
      MetaTransactionExecutedV2Event.OutputTuple,
      MetaTransactionExecutedV2Event.OutputObject
    >;
    MetaTransactionExecutedV2: TypedContractEvent<
      MetaTransactionExecutedV2Event.InputTuple,
      MetaTransactionExecutedV2Event.OutputTuple,
      MetaTransactionExecutedV2Event.OutputObject
    >;

    "Migrated(address,address,address)": TypedContractEvent<
      MigratedEvent.InputTuple,
      MigratedEvent.OutputTuple,
      MigratedEvent.OutputObject
    >;
    Migrated: TypedContractEvent<
      MigratedEvent.InputTuple,
      MigratedEvent.OutputTuple,
      MigratedEvent.OutputObject
    >;

    "OrderCancelled(bytes32,address)": TypedContractEvent<
      OrderCancelledEvent.InputTuple,
      OrderCancelledEvent.OutputTuple,
      OrderCancelledEvent.OutputObject
    >;
    OrderCancelled: TypedContractEvent<
      OrderCancelledEvent.InputTuple,
      OrderCancelledEvent.OutputTuple,
      OrderCancelledEvent.OutputObject
    >;

    "OrderSignerRegistered(address,address,bool)": TypedContractEvent<
      OrderSignerRegisteredEvent.InputTuple,
      OrderSignerRegisteredEvent.OutputTuple,
      OrderSignerRegisteredEvent.OutputObject
    >;
    OrderSignerRegistered: TypedContractEvent<
      OrderSignerRegisteredEvent.InputTuple,
      OrderSignerRegisteredEvent.OutputTuple,
      OrderSignerRegisteredEvent.OutputObject
    >;

    "OtcOrderFilled(bytes32,address,address,address,address,uint128,uint128)": TypedContractEvent<
      OtcOrderFilledEvent.InputTuple,
      OtcOrderFilledEvent.OutputTuple,
      OtcOrderFilledEvent.OutputObject
    >;
    OtcOrderFilled: TypedContractEvent<
      OtcOrderFilledEvent.InputTuple,
      OtcOrderFilledEvent.OutputTuple,
      OtcOrderFilledEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "PairCancelledLimitOrders(address,address,address,uint256)": TypedContractEvent<
      PairCancelledLimitOrdersEvent.InputTuple,
      PairCancelledLimitOrdersEvent.OutputTuple,
      PairCancelledLimitOrdersEvent.OutputObject
    >;
    PairCancelledLimitOrders: TypedContractEvent<
      PairCancelledLimitOrdersEvent.InputTuple,
      PairCancelledLimitOrdersEvent.OutputTuple,
      PairCancelledLimitOrdersEvent.OutputObject
    >;

    "PairCancelledRfqOrders(address,address,address,uint256)": TypedContractEvent<
      PairCancelledRfqOrdersEvent.InputTuple,
      PairCancelledRfqOrdersEvent.OutputTuple,
      PairCancelledRfqOrdersEvent.OutputObject
    >;
    PairCancelledRfqOrders: TypedContractEvent<
      PairCancelledRfqOrdersEvent.InputTuple,
      PairCancelledRfqOrdersEvent.OutputTuple,
      PairCancelledRfqOrdersEvent.OutputObject
    >;

    "ProxyFunctionUpdated(bytes4,address,address)": TypedContractEvent<
      ProxyFunctionUpdatedEvent.InputTuple,
      ProxyFunctionUpdatedEvent.OutputTuple,
      ProxyFunctionUpdatedEvent.OutputObject
    >;
    ProxyFunctionUpdated: TypedContractEvent<
      ProxyFunctionUpdatedEvent.InputTuple,
      ProxyFunctionUpdatedEvent.OutputTuple,
      ProxyFunctionUpdatedEvent.OutputObject
    >;

    "QuoteSignerUpdated(address)": TypedContractEvent<
      QuoteSignerUpdatedEvent.InputTuple,
      QuoteSignerUpdatedEvent.OutputTuple,
      QuoteSignerUpdatedEvent.OutputObject
    >;
    QuoteSignerUpdated: TypedContractEvent<
      QuoteSignerUpdatedEvent.InputTuple,
      QuoteSignerUpdatedEvent.OutputTuple,
      QuoteSignerUpdatedEvent.OutputObject
    >;

    "RfqOrderFilled(bytes32,address,address,address,address,uint128,uint128,bytes32)": TypedContractEvent<
      RfqOrderFilledEvent.InputTuple,
      RfqOrderFilledEvent.OutputTuple,
      RfqOrderFilledEvent.OutputObject
    >;
    RfqOrderFilled: TypedContractEvent<
      RfqOrderFilledEvent.InputTuple,
      RfqOrderFilledEvent.OutputTuple,
      RfqOrderFilledEvent.OutputObject
    >;

    "RfqOrderOriginsAllowed(address,address[],bool)": TypedContractEvent<
      RfqOrderOriginsAllowedEvent.InputTuple,
      RfqOrderOriginsAllowedEvent.OutputTuple,
      RfqOrderOriginsAllowedEvent.OutputObject
    >;
    RfqOrderOriginsAllowed: TypedContractEvent<
      RfqOrderOriginsAllowedEvent.InputTuple,
      RfqOrderOriginsAllowedEvent.OutputTuple,
      RfqOrderOriginsAllowedEvent.OutputObject
    >;

    "TransformedERC20(address,address,address,uint256,uint256)": TypedContractEvent<
      TransformedERC20Event.InputTuple,
      TransformedERC20Event.OutputTuple,
      TransformedERC20Event.OutputObject
    >;
    TransformedERC20: TypedContractEvent<
      TransformedERC20Event.InputTuple,
      TransformedERC20Event.OutputTuple,
      TransformedERC20Event.OutputObject
    >;

    "TransformerDeployerUpdated(address)": TypedContractEvent<
      TransformerDeployerUpdatedEvent.InputTuple,
      TransformerDeployerUpdatedEvent.OutputTuple,
      TransformerDeployerUpdatedEvent.OutputObject
    >;
    TransformerDeployerUpdated: TypedContractEvent<
      TransformerDeployerUpdatedEvent.InputTuple,
      TransformerDeployerUpdatedEvent.OutputTuple,
      TransformerDeployerUpdatedEvent.OutputObject
    >;
  };
}
