import { ethers } from "ethers";
import {
    blockchainTests,
    constants,
    describe,
    expect,
    getRandomPortion,
    verifyEventsFromLogs,
} from '@0x/test-utils';
import { LimitOrder, LimitOrderFields, OrderStatus, RevertErrors, RfqOrder, RfqOrderFields } from '@0x/protocol-utils';
import { } from '@0x/utils';
import { TransactionReceiptWithDecodedLogs } from 'ethereum-types';
import * as _ from 'lodash';

import { 
    BatchFillNativeOrdersFeatureContract, 
    IZeroExContract, 
    IZeroExEvents,
    BatchFillNativeOrdersFeature__factory
} from '../../src/wrappers';
import { artifacts } from '../artifacts';
import { abis } from '../utils/abis';
import {
    assertOrderInfoEquals,
    computeLimitOrderFilledAmounts,
    computeRfqOrderFilledAmounts,
    createExpiry,
    getRandomLimitOrder,
    getRandomRfqOrder,
    NativeOrdersTestEnvironment,
} from '../utils/orders';
import { TestMintableERC20TokenContract } from '../wrappers';

blockchainTests('BatchFillNativeOrdersFeature', env => {
    const { NULL_ADDRESS, ZERO_AMOUNT } = constants;
    let maker: string;
    let taker: string;
    let zeroEx: IZeroExContract;
    let feature: BatchFillNativeOrdersFeatureContract;
    let verifyingContract: string;
    let makerToken: TestMintableERC20TokenContract;
    let takerToken: TestMintableERC20TokenContract;
    let testUtils: NativeOrdersTestEnvironment;

    before(async () => {
        testUtils = await NativeOrdersTestEnvironment.createAsync(env);
        maker = testUtils.maker;
        taker = testUtils.taker;
        zeroEx = testUtils.zeroEx;
        makerToken = testUtils.makerToken;
        takerToken = testUtils.takerToken;

        verifyingContract = await zeroEx.getAddress();
        const [owner] = await env.getAccountAddressesAsync();
        const signer = await env.provider.getSigner(owner);
        
        const featureFactory = new BatchFillNativeOrdersFeature__factory(signer);
        const featureImpl = await featureFactory.deploy(await zeroEx.getAddress());
        await featureImpl.waitForDeployment();
        
        const ownerSigner = await env.provider.getSigner(owner);
        await zeroEx
            .connect(ownerSigner)
            .migrate(await featureImpl.getAddress(), featureImpl.migrate().getABIEncodedTransactionData(), owner);
            
        feature = new BatchFillNativeOrdersFeatureContract(
            await zeroEx.getAddress(),
            env.provider,
            { ...env.txDefaults, gasPrice: testUtils.gasPrice },
            abis,
        );
    });

    async function getTestLimitOrder(fields: Partial<LimitOrderFields> = {}): Promise<LimitOrder> {
        return getRandomLimitOrder({
            maker,
            verifyingContract,
            chainId: 1337,
            takerToken: await takerToken.getAddress(),
            makerToken: await makerToken.getAddress(),
            taker: NULL_ADDRESS,
            sender: NULL_ADDRESS,
            ...fields,
        });
    }
    async function getTestRfqOrder(fields: Partial<RfqOrderFields> = {}): Promise<RfqOrder> {
        return getRandomRfqOrder({
            maker,
            verifyingContract,
            chainId: 1337,
            takerToken: await takerToken.getAddress(),
            makerToken: await makerToken.getAddress(),
            txOrigin: taker,
            ...fields,
        });
    }

    describe('batchFillLimitOrders', () => {
        async function assertExpectedFinalBalancesAsync(
            orders: LimitOrder[],
            takerTokenFillAmounts: bigint[] = orders.map(order => order.takerAmount),
            takerTokenAlreadyFilledAmounts: bigint[] = orders.map(() => ZERO_AMOUNT),
            receipt?: TransactionReceiptWithDecodedLogs,
        ): Promise<void> {
            const expectedFeeRecipientBalances: { [feeRecipient: string]: bigint } = {};
            const { makerTokenFilledAmount, takerTokenFilledAmount } = orders
                .map((order, i) =>
                    computeLimitOrderFilledAmounts(order, takerTokenFillAmounts[i], takerTokenAlreadyFilledAmounts[i]),
                )
                .reduce(
                    (previous, current, i) => {
                        _.update(expectedFeeRecipientBalances, orders[i].feeRecipient, balance =>
                            (balance || ZERO_AMOUNT) + current.takerTokenFeeFilledAmount,
                        );
                        return {
                            makerTokenFilledAmount: previous.makerTokenFilledAmount.plus(
                                current.makerTokenFilledAmount,
                            ),
                            takerTokenFilledAmount: previous.takerTokenFilledAmount.plus(
                                current.takerTokenFilledAmount,
                            ),
                        };
                    },
                    { makerTokenFilledAmount: ZERO_AMOUNT, takerTokenFilledAmount: ZERO_AMOUNT },
                );
            const makerBalance = await takerToken.balanceOf(maker)();
            const takerBalance = await makerToken.balanceOf(taker)();
            expect(makerBalance, 'maker token balance').to.eq(takerTokenFilledAmount);
            expect(takerBalance, 'taker token balance').to.eq(makerTokenFilledAmount);
            for (const [feeRecipient, expectedFeeRecipientBalance] of Object.entries(expectedFeeRecipientBalances)) {
                const feeRecipientBalance = await takerToken.balanceOf(feeRecipient)();
                expect(feeRecipientBalance, `fee recipient balance`).to.eq(expectedFeeRecipientBalance);
            }
            if (receipt) {
                const balanceOfTakerNow = await env.web3Wrapper.getBalanceInWeiAsync(taker);
                const balanceOfTakerBefore = await env.web3Wrapper.getBalanceInWeiAsync(taker, receipt.blockNumber - 1);
                const protocolFees = testUtils.protocolFee * orders.length;
                const totalCost = testUtils.gasPrice * receipt.gasUsed + protocolFees;
                expect(balanceOfTakerBefore - totalCost, 'taker ETH balance').to.eq(balanceOfTakerNow);
            }
        }

        it('Fully fills multiple orders', async () => {
            const orders = await Promise.all(await Promise.all([...new Array(3)].map(async () => getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT })));
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length;
            const tx = await feature
                .batchFillLimitOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    false,
                )
                ({ from: taker, value });
            const [orderInfos] = await zeroEx.batchGetLimitOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: orders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map(order => testUtils.createLimitOrderFilledEventArgs(order)),
                IZeroExEvents.LimitOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders);
        });
        it('Partially fills multiple orders', async () => {
            const orders = [...new Array(3)].map(getTestLimitOrder);
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length;
            const fillAmounts = orders.map(order => getRandomPortion(order.takerAmount));
            const tx = await feature
                .batchFillLimitOrders(orders, signatures, fillAmounts, false)
                ({ from: taker, value });
            const [orderInfos] = await zeroEx.batchGetLimitOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Fillable,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: fillAmounts[i],
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map((order, i) => testUtils.createLimitOrderFilledEventArgs(order, fillAmounts[i])),
                IZeroExEvents.LimitOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders, fillAmounts);
        });
        it('Fills multiple orders and refunds excess ETH', async () => {
            const orders = await Promise.all([...new Array(3)].map(async () => getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT }));
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length + 420;
            const tx = await feature
                .batchFillLimitOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    false,
                )
                ({ from: taker, value });
            const [orderInfos] = await zeroEx.batchGetLimitOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: orders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map(order => testUtils.createLimitOrderFilledEventArgs(order)),
                IZeroExEvents.LimitOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders);
        });
        it('Skips over unfillable orders and refunds excess ETH', async () => {
            const fillableOrders = await Promise.all([...new Array(3)].map(async () => getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT }));
            const expiredOrder = await getTestLimitOrder({ expiry: createExpiry(-1), takerTokenFeeAmount: ZERO_AMOUNT });
            const orders = [expiredOrder, ...fillableOrders];
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length;
            const tx = await feature
                .batchFillLimitOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    false,
                )
                ({ from: taker, value });
            const [orderInfos] = await zeroEx.batchGetLimitOrderRelevantStates(orders, signatures)();
            const [expiredOrderInfo, ...filledOrderInfos] = orderInfos;
            assertOrderInfoEquals(expiredOrderInfo, {
                status: OrderStatus.Expired,
                orderHash: expiredOrder.getHash(),
                takerTokenFilledAmount: ZERO_AMOUNT,
            });
            filledOrderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: fillableOrders[i].getHash(),
                    takerTokenFilledAmount: fillableOrders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                fillableOrders.map(order => testUtils.createLimitOrderFilledEventArgs(order)),
                IZeroExEvents.LimitOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(fillableOrders);
        });
        it('Fills multiple orders with revertIfIncomplete=true', async () => {
            const orders = await Promise.all([...new Array(3)].map(async () => getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT }));
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length;
            const tx = await feature
                .batchFillLimitOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    true,
                )
                ({ from: taker, value });
            const [orderInfos] = await zeroEx.batchGetLimitOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: orders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map(order => testUtils.createLimitOrderFilledEventArgs(order)),
                IZeroExEvents.LimitOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders);
        });
        it('If revertIfIncomplete==true, reverts on an unfillable order', async () => {
            const fillableOrders = await Promise.all([...new Array(3)].map(async () => getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT }));
            const expiredOrder = await getTestLimitOrder({ expiry: createExpiry(-1), takerTokenFeeAmount: ZERO_AMOUNT });
            const orders = [expiredOrder, ...fillableOrders];
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length;
            const tx = feature
                .batchFillLimitOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    true,
                )
                ({ from: taker, value });
            return expect(tx).to.be.revertedWith(
                new RevertErrors.NativeOrders.BatchFillIncompleteError(
                    expiredOrder.getHash(),
                    ZERO_AMOUNT,
                    expiredOrder.takerAmount,
                ),
            );
        });
        it('If revertIfIncomplete==true, reverts on an incomplete fill ', async () => {
            const fillableOrders = await Promise.all([...new Array(3)].map(async () => getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT }));
            const partiallyFilledOrder = await getTestLimitOrder({ takerTokenFeeAmount: ZERO_AMOUNT });
            const partialFillAmount = getRandomPortion(partiallyFilledOrder.takerAmount);
            await testUtils.fillLimitOrderAsync(partiallyFilledOrder, { fillAmount: partialFillAmount });
            const orders = [partiallyFilledOrder, ...fillableOrders];
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const value = testUtils.protocolFee * orders.length;
            const tx = feature
                .batchFillLimitOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    true,
                )
                ({ from: taker, value });
            return expect(tx).to.be.revertedWith(
                new RevertErrors.NativeOrders.BatchFillIncompleteError(
                    partiallyFilledOrder.getHash(),
                    partiallyFilledOrder.takerAmount - partialFillAmount,
                    partiallyFilledOrder.takerAmount,
                ),
            );
        });
    });
    describe('batchFillRfqOrders', () => {
        async function assertExpectedFinalBalancesAsync(
            orders: RfqOrder[],
            takerTokenFillAmounts: bigint[] = orders.map(order => order.takerAmount),
            takerTokenAlreadyFilledAmounts: bigint[] = orders.map(() => ZERO_AMOUNT),
        ): Promise<void> {
            const { makerTokenFilledAmount, takerTokenFilledAmount } = orders
                .map((order, i) =>
                    computeRfqOrderFilledAmounts(order, takerTokenFillAmounts[i], takerTokenAlreadyFilledAmounts[i]),
                )
                .reduce((previous, current) => ({
                    makerTokenFilledAmount: previous.makerTokenFilledAmount + current.makerTokenFilledAmount,
                    takerTokenFilledAmount: previous.takerTokenFilledAmount + current.takerTokenFilledAmount,
                }));
            const makerBalance = await takerToken.balanceOf(maker)();
            const takerBalance = await makerToken.balanceOf(taker)();
            expect(makerBalance).to.eq(takerTokenFilledAmount);
            expect(takerBalance).to.eq(makerTokenFilledAmount);
        }

        it('Fully fills multiple orders', async () => {
            const orders = await Promise.all([...new Array(3)].map(async () => getTestRfqOrder());
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const tx = await feature
                .batchFillRfqOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    false,
                )
                ({ from: taker });
            const [orderInfos] = await zeroEx.batchGetRfqOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: orders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map(order => testUtils.createRfqOrderFilledEventArgs(order)),
                IZeroExEvents.RfqOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders);
        });
        it('Partially fills multiple orders', async () => {
            const orders = await Promise.all([...new Array(3)].map(async () => getTestRfqOrder());
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            const fillAmounts = orders.map(order => getRandomPortion(order.takerAmount));
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const tx = await feature
                .batchFillRfqOrders(orders, signatures, fillAmounts, false)
                ({ from: taker });
            const [orderInfos] = await zeroEx.batchGetRfqOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Fillable,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: fillAmounts[i],
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map((order, i) => testUtils.createRfqOrderFilledEventArgs(order, fillAmounts[i])),
                IZeroExEvents.RfqOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders, fillAmounts);
        });
        it('Skips over unfillable orders', async () => {
            const fillableOrders = await Promise.all([...new Array(3)].map(async () => getTestRfqOrder());
            const expiredOrder = await getTestRfqOrder({ expiry: createExpiry(-1) });
            const orders = [expiredOrder, ...fillableOrders];
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const tx = await feature
                .batchFillRfqOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    false,
                )
                ({ from: taker });
            const [orderInfos] = await zeroEx.batchGetRfqOrderRelevantStates(orders, signatures)();
            const [expiredOrderInfo, ...filledOrderInfos] = orderInfos;
            assertOrderInfoEquals(expiredOrderInfo, {
                status: OrderStatus.Expired,
                orderHash: expiredOrder.getHash(),
                takerTokenFilledAmount: ZERO_AMOUNT,
            });
            filledOrderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: fillableOrders[i].getHash(),
                    takerTokenFilledAmount: fillableOrders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                fillableOrders.map(order => testUtils.createRfqOrderFilledEventArgs(order)),
                IZeroExEvents.RfqOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(fillableOrders);
        });
        it('Fills multiple orders with revertIfIncomplete=true', async () => {
            const orders = await Promise.all([...new Array(3)].map(async () => getTestRfqOrder());
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const tx = await feature
                .batchFillRfqOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    true,
                )
                ({ from: taker });
            const [orderInfos] = await zeroEx.batchGetRfqOrderRelevantStates(orders, signatures)();
            orderInfos.map((orderInfo, i) =>
                assertOrderInfoEquals(orderInfo, {
                    status: OrderStatus.Filled,
                    orderHash: orders[i].getHash(),
                    takerTokenFilledAmount: orders[i].takerAmount,
                }),
            );
            verifyEventsFromLogs(
                tx.logs,
                orders.map(order => testUtils.createRfqOrderFilledEventArgs(order)),
                IZeroExEvents.RfqOrderFilled,
            );
            return assertExpectedFinalBalancesAsync(orders);
        });
        it('If revertIfIncomplete==true, reverts on an unfillable order', async () => {
            const fillableOrders = await Promise.all([...new Array(3)].map(async () => getTestRfqOrder());
            const expiredOrder = await getTestRfqOrder({ expiry: createExpiry(-1) });
            const orders = [expiredOrder, ...fillableOrders];
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const tx = feature
                .batchFillRfqOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    true,
                )
                ({ from: taker });
            return expect(tx).to.be.revertedWith(
                new RevertErrors.NativeOrders.BatchFillIncompleteError(
                    expiredOrder.getHash(),
                    ZERO_AMOUNT,
                    expiredOrder.takerAmount,
                ),
            );
        });
        it('If revertIfIncomplete==true, reverts on an incomplete fill ', async () => {
            const fillableOrders = await Promise.all([...new Array(3)].map(async () => getTestRfqOrder());
            const partiallyFilledOrder = await getTestRfqOrder();
            const partialFillAmount = getRandomPortion(partiallyFilledOrder.takerAmount);
            await testUtils.fillRfqOrderAsync(partiallyFilledOrder, partialFillAmount);
            const orders = [partiallyFilledOrder, ...fillableOrders];
            const signatures = await Promise.all(
                orders.map(order => order.getSignatureWithProviderAsync(env.provider)),
            );
            await testUtils.prepareBalancesForOrdersAsync(orders);
            const tx = feature
                .batchFillRfqOrders(
                    orders,
                    signatures,
                    orders.map(order => order.takerAmount),
                    true,
                )
                ({ from: taker });
            return expect(tx).to.be.revertedWith(
                new RevertErrors.NativeOrders.BatchFillIncompleteError(
                    partiallyFilledOrder.getHash(),
                    partiallyFilledOrder.takerAmount - partialFillAmount,
                    partiallyFilledOrder.takerAmount,
                ),
            );
        });
    });
});
