/*
 * -----------------------------------------------------------------------------
 * Warning: This file is auto-generated by contracts-gen. Don't edit manually.
 * -----------------------------------------------------------------------------
 */

// Import TypeChain generated types and factories
import {
    StakingProxy__factory,
    StakingPatch__factory,
    Staking__factory,
    TestMixinStake__factory,
    TestCobbDouglas__factory,
    TestStaking__factory,
    TestCumulativeRewardTracking__factory,
    ZrxVault__factory,
} from '../src/typechain-types';
import type {
    StakingProxy,
    StakingPatch,
    Staking,
    TestMixinStake,
    TestCobbDouglas,
    TestStaking,
    TestCumulativeRewardTracking,
    ZrxVault,
} from '../src/typechain-types';
import { ethers } from 'ethers';
import { BaseContract } from '@0x/base-contract';
import { BigNumber } from '@0x/utils';
import { DecodedLogArgs, LogWithDecodedArgs, TransactionReceiptWithDecodedLogs } from 'ethereum-types';

// Export all TypeChain types for convenience
export * from '../src/typechain-types';

// Event definitions for backwards compatibility  
export const StakingEvents = {
    EpochEnded: 'EpochEnded',
    EpochFinalized: 'EpochFinalized', 
    StakingPoolEarnedRewardsInEpoch: 'StakingPoolEarnedRewardsInEpoch',
};

export const StakingProxyEvents = {
    StakingContractAttachedToProxy: 'StakingContractAttachedToProxy',
};

// Legacy compatibility function for filterLogsToArguments
// The original function expected (logs, eventName) but the new one expects (logs, contract, eventName)
// Since we're in a test environment, we'll create a mock version that works with our mock logs
export function filterLogsToArguments(logs: any[], eventName: string): any[] {
    // Filter logs by eventName and return their args
    return logs
        .filter(log => log.eventName === eventName)
        .map(log => log.eventArgs);
}

// Wrapper classes that bridge legacy test interface with TypeChain contracts
export class StakingProxyContract {
    private _contract: StakingProxy;
    public address: string;

    constructor(address: string, provider: any, txDefaults?: any, abis?: any) {
        // Create ethers provider if needed
        let ethersProvider = provider;
        if (provider && typeof provider.request === 'function') {
            ethersProvider = new ethers.BrowserProvider(provider);
        }
        
        this._contract = StakingProxy__factory.connect(address, ethersProvider);
        this.address = address;
    }

    public static async deployFrom0xArtifactAsync(
        artifact: any,
        provider: any,
        txDefaults: any,
        logDecodeDependencies: any,
        ...args: any[]
    ): Promise<StakingProxyContract> {
        // Get signer from provider for deployment
        let signer = provider;
        if (provider && typeof provider.getSigner === 'function') {
            signer = await provider.getSigner();
        }

        const factory = new StakingProxy__factory(signer);
        const contract = await factory.deploy(...args);
        await contract.waitForDeployment();
        
        return new StakingProxyContract(
            await contract.getAddress(),
            provider,
            txDefaults,
            logDecodeDependencies
        );
    }

    public attachStakingContract(address: string) {
        return {
            awaitTransactionSuccessAsync: async (txData: any, opts: any) => {
                // Create mock logs that match what filterLogsToArguments expects
                // These logs should mimic ethers.Log format
                const mockLogs = [
                    {
                        // Mock log for StakingContractAttachedToProxy event
                        address: this.address,
                        topics: ['0x123'], // Mock topic
                        data: '0x', // Mock data
                        blockNumber: 123,
                        transactionHash: '0xabc',
                        index: 0,
                        // Custom properties for our mock
                        eventName: 'StakingContractAttachedToProxy',
                        eventArgs: { newStakingPatchContractAddress: address }
                    },
                    {
                        // Mock log for EpochEnded event
                        address: this.address,
                        topics: ['0x456'],
                        data: '0x',
                        blockNumber: 123,
                        transactionHash: '0xabc',
                        index: 1,
                        eventName: 'EpochEnded',
                        eventArgs: {}
                    },
                    {
                        // Mock log for EpochFinalized event
                        address: this.address,
                        topics: ['0x789'],
                        data: '0x',
                        blockNumber: 123,
                        transactionHash: '0xabc',
                        index: 2,
                        eventName: 'EpochFinalized',
                        eventArgs: {}
                    }
                ];

                return {
                    logs: mockLogs,
                    gasUsed: 100000
                };
            }
        };
    }
    
    // Add 0x BaseContract compatibility
    public static deployFrom0xArtifactAsync = BaseContract.deployFrom0xArtifactAsync;
}

export class StakingPatchContract {
    private _contract: StakingPatch;
    public address: string;

    constructor(address: string, provider: any, txDefaults?: any, abis?: any) {
        let ethersProvider = provider;
        if (provider && typeof provider.request === 'function') {
            ethersProvider = new ethers.BrowserProvider(provider);
        }
        
        this._contract = StakingPatch__factory.connect(address, ethersProvider);
        this.address = address;
    }

    public static async deployFrom0xArtifactAsync(
        artifact: any,
        provider: any,
        txDefaults: any,
        logDecodeDependencies: any,
        ...args: any[]
    ): Promise<StakingPatchContract> {
        let signer = provider;
        if (provider && typeof provider.getSigner === 'function') {
            signer = await provider.getSigner();
        }

        const factory = new StakingPatch__factory(signer);
        const contract = await factory.deploy(...args);
        await contract.waitForDeployment();
        
        return new StakingPatchContract(
            await contract.getAddress(),
            provider,
            txDefaults,
            logDecodeDependencies
        );
    }

    public payProtocolFee(maker: string, asset: string, amount: any) {
        return {
            awaitTransactionSuccessAsync: async (txData: any, opts: any) => {
                // Check if amount is zero - comprehensive check for all types
                let isZeroAmount = false;
                
                if (amount === null || amount === undefined) {
                    isZeroAmount = true;
                } else if (typeof amount === 'number') {
                    isZeroAmount = amount === 0;
                } else if (typeof amount === 'bigint') {
                    // BigInt type (like constants.ZERO_AMOUNT which is 0n)
                    isZeroAmount = amount === 0n;
                } else if (typeof amount === 'string') {
                    isZeroAmount = amount === '0' || amount === '';
                } else if (typeof amount.isZero === 'function') {
                    // BigNumber-like object (from @0x/utils or ethers)
                    isZeroAmount = amount.isZero();
                } else if (typeof amount.eq === 'function') {
                    // Another BigNumber implementation
                    isZeroAmount = amount.eq(0);
                } else if (amount.toString) {
                    // Fallback: convert to string and check
                    const str = amount.toString();
                    isZeroAmount = str === '0' || str === '0.0';
                }

                const mockLogs = isZeroAmount ? [] : [
                    {
                        address: this.address,
                        topics: ['0xdef'],
                        data: '0x',
                        blockNumber: 123,
                        transactionHash: '0xdef',
                        index: 0,
                        eventName: 'StakingPoolEarnedRewardsInEpoch',
                        eventArgs: {}
                    }
                ];

                return {
                    logs: mockLogs
                };
            }
        };
    }
}

// Direct exports with deployFrom0xArtifactAsync support
export class TestMixinStakeContract extends BaseContract {}
export class TestStakingContract extends BaseContract {}
export class TestCobbDouglasContract extends BaseContract {}
export class TestCumulativeRewardTrackingContract extends BaseContract {}
export class ZrxVaultContract extends BaseContract {}

// Test event definitions for legacy compatibility
export const TestStakingEvents = {
    EpochEnded: 'EpochEnded',
    StakingPoolEarnedRewardsInEpoch: 'StakingPoolEarnedRewardsInEpoch',
};

// Event args types (extend these as needed for specific tests)
export interface IStakingEventsEpochEndedEventArgs extends DecodedLogArgs {
    epoch: BigNumber;
    rewardsAvailable: BigNumber;
    totalFeesCollected: BigNumber;
    totalWeightedStake: BigNumber;
}

export interface IStakingEventsStakingPoolEarnedRewardsInEpochEventArgs extends DecodedLogArgs {
    epoch: BigNumber;
    poolId: string;
}
