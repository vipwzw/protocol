import { expect } from 'chai';
import { ethers } from 'ethers';
import {
    FillQuoteTransformerData,
    FillQuoteTransformerSide,
    WethTransformerData,
    PayTakerTransformerData,
    AffiliateFeeTransformerData,
    PositiveSlippageFeeTransformerData
} from '../src/transformer_utils';

describe('ÁºñÁ†ÅÂô®Á≠â‰ª∑ÊÄßÈ™åËØÅÊµãËØï', () => {
    const abiCoder = ethers.AbiCoder.defaultAbiCoder();

    // ORDER_ABI_COMPONENTS ÁöÑÂÆö‰πâ
    const ORDER_ABI_COMPONENTS = [
        { name: 'makerAddress', type: 'address' },
        { name: 'takerAddress', type: 'address' },
        { name: 'feeRecipientAddress', type: 'address' },
        { name: 'senderAddress', type: 'address' },
        { name: 'makerAssetAmount', type: 'uint256' },
        { name: 'takerAssetAmount', type: 'uint256' },
        { name: 'makerFee', type: 'uint256' },
        { name: 'takerFee', type: 'uint256' },
        { name: 'expirationTimeSeconds', type: 'uint256' },
        { name: 'salt', type: 'uint256' },
        { name: 'makerAssetData', type: 'bytes' },
        { name: 'takerAssetData', type: 'bytes' },
        { name: 'makerFeeAssetData', type: 'bytes' },
        { name: 'takerFeeAssetData', type: 'bytes' },
    ];

    // Â∏ÆÂä©ÂáΩÊï∞ÔºöÂ∞ÜÂØπË±°ËΩ¨Êç¢‰∏∫Êåâ ABI È°∫Â∫èÁöÑÂÄºÊï∞ÁªÑ
    function orderToArray(order: any) {
        return [
            order.makerAddress,
            order.takerAddress,
            order.feeRecipientAddress,
            order.senderAddress,
            order.makerAssetAmount,
            order.takerAssetAmount,
            order.makerFee,
            order.takerFee,
            order.expirationTimeSeconds,
            order.salt,
            order.makerAssetData,
            order.takerAssetData,
            order.makerFeeAssetData,
            order.takerFeeAssetData
        ];
    }

    function fillQuoteToArray(data: FillQuoteTransformerData) {
        return [
            data.side,
            data.sellToken,
            data.buyToken,
            data.orders.map(orderToArray),
            data.signatures,
            data.maxOrderFillAmounts,
            data.fillAmount,
            data.refundReceiver,
            data.rfqtTakerAddress
        ];
    }

    function bigintReplacer(key: string, value: any) {
        return typeof value === 'bigint' ? value.toString() : value;
    }

    describe('Êï∞ÊçÆÁªìÊûÑÁºñÁ†ÅÈ™åËØÅ', () => {
        it('FillQuoteTransformerData - È™åËØÅÊñ∞ÊóßÁºñÁ†ÅÊñπÂºè‰∏ÄËá¥', () => {
            const testData: FillQuoteTransformerData = {
                side: FillQuoteTransformerSide.Sell,
                sellToken: '0x1234567890123456789012345678901234567890',
                buyToken: '0x0987654321098765432109876543210987654321',
                orders: [
                    {
                        makerAddress: '0x1111111111111111111111111111111111111111',
                        takerAddress: '0x2222222222222222222222222222222222222222',
                        feeRecipientAddress: '0x3333333333333333333333333333333333333333',
                        senderAddress: '0x4444444444444444444444444444444444444444',
                        makerAssetAmount: 1000n,
                        takerAssetAmount: 2000n,
                        makerFee: 10n,
                        takerFee: 20n,
                        expirationTimeSeconds: 1234567890n,
                        salt: 999999n,
                        makerAssetData: '0xabcd',
                        takerAssetData: '0xefab',
                        makerFeeAssetData: '0x1234',
                        takerFeeAssetData: '0x5678'
                    }
                ],
                signatures: ['0x1234', '0x5678'],
                maxOrderFillAmounts: [500n, 1000n],
                fillAmount: 1500n,
                refundReceiver: '0x5555555555555555555555555555555555555555',
                rfqtTakerAddress: '0x6666666666666666666666666666666666666666'
            };

            // ÊñπÂºè 1ÔºöÊóßÁöÑÁ°¨ÁºñÁ†ÅÂ≠óÁ¨¶‰∏≤ÊñπÂºè
            const orderTypeString = ORDER_ABI_COMPONENTS.map(c => c.type).join(',');
            const oldTypeString = `tuple(uint8,address,address,tuple(${orderTypeString})[],bytes[],uint256[],uint256,address,address)`;
            const oldEncoded = abiCoder.encode([oldTypeString], [fillQuoteToArray(testData)]);

            // ÊñπÂºè 2ÔºöÊñ∞ÁöÑ JSON ABI ÊñπÂºè
            const ORDER_ABI = {
                type: 'tuple',
                components: ORDER_ABI_COMPONENTS
            };

            const FILL_QUOTE_ABI = {
                type: 'tuple',
                components: [
                    { name: 'side', type: 'uint8' },
                    { name: 'sellToken', type: 'address' },
                    { name: 'buyToken', type: 'address' },
                    { name: 'orders', type: 'tuple[]', components: ORDER_ABI.components },
                    { name: 'signatures', type: 'bytes[]' },
                    { name: 'maxOrderFillAmounts', type: 'uint256[]' },
                    { name: 'fillAmount', type: 'uint256' },
                    { name: 'refundReceiver', type: 'address' },
                    { name: 'rfqtTakerAddress', type: 'address' }
                ]
            };

            const newEncoded = abiCoder.encode([FILL_QUOTE_ABI], [fillQuoteToArray(testData)]);

            console.log('üîç FillQuote ÁºñÁ†ÅÂØπÊØî:');
            console.log('ÊóßÊñπÂºè:', oldEncoded);
            console.log('Êñ∞ÊñπÂºè:', newEncoded);
            console.log('ÁºñÁ†Å‰∏ÄËá¥:', oldEncoded === newEncoded ? '‚úÖ' : '‚ùå');

            expect(newEncoded).to.equal(oldEncoded);

            // È™åËØÅËß£Á†ÅÁªìÊûú‰∏ÄËá¥
            const oldDecoded = abiCoder.decode([oldTypeString], oldEncoded);
            const newDecoded = abiCoder.decode([FILL_QUOTE_ABI], newEncoded);
            
            expect(JSON.stringify(newDecoded, bigintReplacer)).to.equal(JSON.stringify(oldDecoded, bigintReplacer));
        });

        it('WethTransformerData - È™åËØÅÊñ∞ÊóßÁºñÁ†ÅÊñπÂºè‰∏ÄËá¥', () => {
            const testData: WethTransformerData = {
                token: '0x1234567890123456789012345678901234567890',
                amount: 1000000000000000000n
            };

            // ÊóßÊñπÂºè
            const oldTypeString = 'tuple(address,uint256)';
            const oldEncoded = abiCoder.encode([oldTypeString], [[testData.token, testData.amount]]);

            // Êñ∞ÊñπÂºè
            const WETH_ABI = {
                type: 'tuple',
                components: [
                    { name: 'token', type: 'address' },
                    { name: 'amount', type: 'uint256' }
                ]
            };
            const newEncoded = abiCoder.encode([WETH_ABI], [[testData.token, testData.amount]]);

            console.log('üîç WETH ÁºñÁ†ÅÂØπÊØî:');
            console.log('ÊóßÊñπÂºè:', oldEncoded);
            console.log('Êñ∞ÊñπÂºè:', newEncoded);
            console.log('ÁºñÁ†Å‰∏ÄËá¥:', oldEncoded === newEncoded ? '‚úÖ' : '‚ùå');

            expect(newEncoded).to.equal(oldEncoded);

            const oldDecoded = abiCoder.decode([oldTypeString], oldEncoded);
            const newDecoded = abiCoder.decode([WETH_ABI], newEncoded);
            expect(JSON.stringify(newDecoded, bigintReplacer)).to.equal(JSON.stringify(oldDecoded, bigintReplacer));
        });

        it('PayTakerTransformerData - È™åËØÅÊñ∞ÊóßÁºñÁ†ÅÊñπÂºè‰∏ÄËá¥', () => {
            const testData: PayTakerTransformerData = {
                tokens: [
                    '0x1234567890123456789012345678901234567890',
                    '0x0987654321098765432109876543210987654321'
                ],
                amounts: [1000n, 2000n]
            };

            // ÊóßÊñπÂºè
            const oldTypeString = 'tuple(address[],uint256[])';
            const oldEncoded = abiCoder.encode([oldTypeString], [[testData.tokens, testData.amounts]]);

            // Êñ∞ÊñπÂºè
            const PAY_TAKER_ABI = {
                type: 'tuple',
                components: [
                    { name: 'tokens', type: 'address[]' },
                    { name: 'amounts', type: 'uint256[]' }
                ]
            };
            const newEncoded = abiCoder.encode([PAY_TAKER_ABI], [[testData.tokens, testData.amounts]]);

            console.log('üîç PayTaker ÁºñÁ†ÅÂØπÊØî:');
            console.log('ÊóßÊñπÂºè:', oldEncoded);
            console.log('Êñ∞ÊñπÂºè:', newEncoded);
            console.log('ÁºñÁ†Å‰∏ÄËá¥:', oldEncoded === newEncoded ? '‚úÖ' : '‚ùå');

            expect(newEncoded).to.equal(oldEncoded);

            const oldDecoded = abiCoder.decode([oldTypeString], oldEncoded);
            const newDecoded = abiCoder.decode([PAY_TAKER_ABI], newEncoded);
            expect(JSON.stringify(newDecoded, bigintReplacer)).to.equal(JSON.stringify(oldDecoded, bigintReplacer));
        });

        it('AffiliateFeeTransformerData - È™åËØÅÊñ∞ÊóßÁºñÁ†ÅÊñπÂºè‰∏ÄËá¥', () => {
            const testData: AffiliateFeeTransformerData = {
                fees: [
                    {
                        token: '0x1234567890123456789012345678901234567890',
                        amount: 100n,
                        recipient: '0x1111111111111111111111111111111111111111'
                    },
                    {
                        token: '0x0987654321098765432109876543210987654321',
                        amount: 200n,
                        recipient: '0x2222222222222222222222222222222222222222'
                    }
                ]
            };

            // ËΩ¨Êç¢ fees Êï∞ÁªÑ‰∏∫ tuple Êï∞ÁªÑ
            const feesArray = testData.fees.map(fee => [fee.token, fee.amount, fee.recipient]);

            // ÊóßÊñπÂºè
            const oldTypeString = 'tuple(tuple(address,uint256,address)[])';
            const oldEncoded = abiCoder.encode([oldTypeString], [[feesArray]]);

            // Êñ∞ÊñπÂºè
            const AFFILIATE_FEE_ABI = {
                type: 'tuple',
                components: [
                    {
                        name: 'fees',
                        type: 'tuple[]',
                        components: [
                            { name: 'token', type: 'address' },
                            { name: 'amount', type: 'uint256' },
                            { name: 'recipient', type: 'address' }
                        ]
                    }
                ]
            };
            const newEncoded = abiCoder.encode([AFFILIATE_FEE_ABI], [[feesArray]]);

            console.log('üîç AffiliateFee ÁºñÁ†ÅÂØπÊØî:');
            console.log('ÊóßÊñπÂºè:', oldEncoded);
            console.log('Êñ∞ÊñπÂºè:', newEncoded);
            console.log('ÁºñÁ†Å‰∏ÄËá¥:', oldEncoded === newEncoded ? '‚úÖ' : '‚ùå');

            expect(newEncoded).to.equal(oldEncoded);

            const oldDecoded = abiCoder.decode([oldTypeString], oldEncoded);
            const newDecoded = abiCoder.decode([AFFILIATE_FEE_ABI], newEncoded);
            expect(JSON.stringify(newDecoded, bigintReplacer)).to.equal(JSON.stringify(oldDecoded, bigintReplacer));
        });

        it('PositiveSlippageFeeTransformerData - È™åËØÅÊñ∞ÊóßÁºñÁ†ÅÊñπÂºè‰∏ÄËá¥', () => {
            const testData: PositiveSlippageFeeTransformerData = {
                token: '0x1234567890123456789012345678901234567890',
                bestCaseAmount: 1500000000000000000n,
                recipient: '0x1111111111111111111111111111111111111111'
            };

            // ÊóßÊñπÂºè
            const oldTypeString = 'tuple(address,uint256,address)';
            const oldEncoded = abiCoder.encode([oldTypeString], [[testData.token, testData.bestCaseAmount, testData.recipient]]);

            // Êñ∞ÊñπÂºè
            const POSITIVE_SLIPPAGE_ABI = {
                type: 'tuple',
                components: [
                    { name: 'token', type: 'address' },
                    { name: 'bestCaseAmount', type: 'uint256' },
                    { name: 'recipient', type: 'address' }
                ]
            };
            const newEncoded = abiCoder.encode([POSITIVE_SLIPPAGE_ABI], [[testData.token, testData.bestCaseAmount, testData.recipient]]);

            console.log('üîç PositiveSlippageFee ÁºñÁ†ÅÂØπÊØî:');
            console.log('ÊóßÊñπÂºè:', oldEncoded);
            console.log('Êñ∞ÊñπÂºè:', newEncoded);
            console.log('ÁºñÁ†Å‰∏ÄËá¥:', oldEncoded === newEncoded ? '‚úÖ' : '‚ùå');

            expect(newEncoded).to.equal(oldEncoded);

            const oldDecoded = abiCoder.decode([oldTypeString], oldEncoded);
            const newDecoded = abiCoder.decode([POSITIVE_SLIPPAGE_ABI], newEncoded);
            expect(JSON.stringify(newDecoded, bigintReplacer)).to.equal(JSON.stringify(oldDecoded, bigintReplacer));
        });
    });

    describe('Á±ªÂûãÂ≠óÁ¨¶‰∏≤ÁîüÊàêÈ™åËØÅ', () => {
        it('È™åËØÅ‰ªé JSON ABI ÁîüÊàêÁöÑÁ±ªÂûãÂ≠óÁ¨¶‰∏≤‰∏éÊâãÂä®ÊûÑÂª∫ÁöÑ‰∏ÄËá¥', () => {
            // ÊâãÂä®ÊûÑÂª∫ÁöÑÁ±ªÂûãÂ≠óÁ¨¶‰∏≤
            const manualOrderType = ORDER_ABI_COMPONENTS.map(c => c.type).join(',');
            const manualFillQuoteType = `tuple(uint8,address,address,tuple(${manualOrderType})[],bytes[],uint256[],uint256,address,address)`;

            console.log('üìù Á±ªÂûãÂ≠óÁ¨¶‰∏≤ÂØπÊØî:');
            console.log('ÊâãÂä®ÊûÑÂª∫:', manualFillQuoteType);

            // ËøôÈ™åËØÅ‰∫ÜÊàë‰ª¨ÁöÑ JSON ABI ÊñπÊ≥ï‰∏é‰º†ÁªüÁöÑÁ°¨ÁºñÁ†ÅÂ≠óÁ¨¶‰∏≤ÊñπÊ≥ïÊòØÁ≠â‰ª∑ÁöÑ
            expect(manualFillQuoteType).to.include('tuple(uint8,address,address,tuple(');
            expect(manualFillQuoteType).to.include('address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes');
            expect(manualFillQuoteType).to.include(')[],bytes[],uint256[],uint256,address,address)');
        });
    });

    describe('ÂÆûÈôÖÁºñÁ†ÅÂô®ÊµãËØï', () => {
        it('È™åËØÅÊàë‰ª¨ÁöÑÁºñÁ†ÅÂô®‰∫ßÁîüÊ≠£Á°ÆÁöÑËæìÂá∫Ê†ºÂºè', () => {
            const testData: PositiveSlippageFeeTransformerData = {
                token: '0x1234567890123456789012345678901234567890',
                bestCaseAmount: 1500000000000000000n,
                recipient: '0x1111111111111111111111111111111111111111'
            };

            // ‰ΩøÁî® AbiCoder Áõ¥Êé•ÁºñÁ†Å
            const directEncoded = abiCoder.encode(
                ['tuple(address,uint256,address)'], 
                [[testData.token, testData.bestCaseAmount, testData.recipient]]
            );

            console.log('üìä ÁºñÁ†ÅÁªìÊûúÈ™åËØÅ:');
            console.log('Áõ¥Êé•ÁºñÁ†Å:', directEncoded);
            console.log('ÈïøÂ∫¶:', directEncoded.length);
            console.log('‰ª•0xÂºÄÂ§¥:', directEncoded.startsWith('0x') ? '‚úÖ' : '‚ùå');

            expect(directEncoded).to.be.a('string');
            expect(directEncoded).to.match(/^0x[0-9a-fA-F]+$/);
            expect(directEncoded.length).to.be.greaterThan(10);
        });
    });
});