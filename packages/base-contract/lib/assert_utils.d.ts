export declare const assert: {
    isETHAddressHex(variableName: string, value: string): void;
    isHexString(variableName: string, value: string): void;
    doesConformToSchema(variableName: string, value: any, schema: object): void;
    isBlockParam(variableName: string, value: any): void;
    fail(message?: string): never;
    fail<T>(actual: T, expected: T, message?: string, operator?: Chai.Operator): never;
    isOk(value: unknown, message?: string): asserts value;
    ok(value: unknown, message?: string): asserts value;
    isNotOk<T>(value: T, message?: string): void;
    notOk<T>(value: T, message?: string): void;
    equal<T>(actual: T, expected: T, message?: string): void;
    notEqual<T>(actual: T, expected: T, message?: string): void;
    strictEqual<T>(actual: T, expected: T, message?: string): void;
    notStrictEqual<T>(actual: T, expected: T, message?: string): void;
    deepEqual<T>(actual: T, expected: T, message?: string): void;
    notDeepEqual<T>(actual: T, expected: T, message?: string): void;
    deepStrictEqual<T>(actual: T, expected: T, message?: string): void;
    isAbove(valueToCheck: number, valueToBeAbove: number, message?: string): void;
    isAtLeast(valueToCheck: number, valueToBeAtLeast: number, message?: string): void;
    isBelow(valueToCheck: number, valueToBeBelow: number, message?: string): void;
    isAtMost(valueToCheck: number, valueToBeAtMost: number, message?: string): void;
    isTrue(value: unknown, message?: string): asserts value is true;
    isFalse(value: unknown, message?: string): asserts value is false;
    isNotTrue<T>(value: T, message?: string): asserts value is Exclude<T, true>;
    isNotFalse<T>(value: T, message?: string): asserts value is Exclude<T, false>;
    isNull(value: unknown, message?: string): asserts value is null;
    isNotNull<T>(value: T, message?: string): asserts value is Exclude<T, null>;
    isNaN<T>(value: T, message?: string): void;
    isNotNaN<T>(value: T, message?: string): void;
    exists<T>(value: T, message?: string): asserts value is NonNullable<T>;
    notExists(value: unknown, message?: string): asserts value is null | undefined;
    isUndefined(value: unknown, message?: string): asserts value is undefined;
    isDefined<T>(value: T, message?: string): asserts value is Exclude<T, undefined>;
    isFunction<T>(value: T, message?: string): void;
    isNotFunction<T>(value: T, message?: string): void;
    isObject<T>(value: T, message?: string): void;
    isNotObject<T>(value: T, message?: string): void;
    isArray<T>(value: T, message?: string): void;
    isNotArray<T>(value: T, message?: string): void;
    isString<T>(value: T, message?: string): void;
    isNotString<T>(value: T, message?: string): void;
    isNumber<T>(value: T, message?: string): void;
    isNotNumber<T>(value: T, message?: string): void;
    isFinite<T>(value: T, message?: string): void;
    isBoolean<T>(value: T, message?: string): void;
    isNotBoolean<T>(value: T, message?: string): void;
    typeOf<T>(value: T, name: string, message?: string): void;
    notTypeOf<T>(value: T, name: string, message?: string): void;
    instanceOf<T>(value: unknown, constructor: Chai.Constructor<T>, message?: string): asserts value is T;
    notInstanceOf<T, U>(value: T, type: Chai.Constructor<U>, message?: string): asserts value is Exclude<T, U>;
    include(haystack: string, needle: string, message?: string): void;
    include<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string): void;
    include<T extends object>(haystack: WeakSet<T>, needle: T, message?: string): void;
    include<T>(haystack: T, needle: Partial<T>, message?: string): void;
    notInclude(haystack: string, needle: string, message?: string): void;
    notInclude<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string): void;
    notInclude<T extends object>(haystack: WeakSet<T>, needle: T, message?: string): void;
    notInclude<T>(haystack: T, needle: Partial<T>, message?: string): void;
    deepInclude(haystack: string, needle: string, message?: string): void;
    deepInclude<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string): void;
    deepInclude<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string): void;
    notDeepInclude(haystack: string, needle: string, message?: string): void;
    notDeepInclude<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string): void;
    notDeepInclude<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string): void;
    nestedInclude(haystack: any, needle: any, message?: string): void;
    notNestedInclude(haystack: any, needle: any, message?: string): void;
    deepNestedInclude(haystack: any, needle: any, message?: string): void;
    notDeepNestedInclude(haystack: any, needle: any, message?: string): void;
    ownInclude(haystack: any, needle: any, message?: string): void;
    notOwnInclude(haystack: any, needle: any, message?: string): void;
    deepOwnInclude(haystack: any, needle: any, message?: string): void;
    notDeepOwnInclude(haystack: any, needle: any, message?: string): void;
    match(value: string, regexp: RegExp, message?: string): void;
    notMatch(expected: any, regexp: RegExp, message?: string): void;
    property<T>(object: T, property: string, message?: string): void;
    notProperty<T>(object: T, property: string, message?: string): void;
    deepProperty<T>(object: T, property: string, message?: string): void;
    notDeepProperty<T>(object: T, property: string, message?: string): void;
    propertyVal<T, V>(object: T, property: string, value: V, message?: string): void;
    notPropertyVal<T, V>(object: T, property: string, value: V, message?: string): void;
    deepPropertyVal<T, V>(object: T, property: string, value: V, message?: string): void;
    notDeepPropertyVal<T, V>(object: T, property: string, value: V, message?: string): void;
    lengthOf<T extends {
        readonly length?: number | undefined;
    } | {
        readonly size?: number | undefined;
    }>(object: T, length: number, message?: string): void;
    throw(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;
    throw(fn: () => void, errorLike?: Chai.ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string): void;
    throws(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;
    throws(fn: () => void, errorLike?: Chai.ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string): void;
    Throw(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;
    Throw(fn: () => void, errorLike?: Chai.ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string): void;
    doesNotThrow(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;
    doesNotThrow(fn: () => void, errorLike?: Chai.ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string): void;
    operator(val1: Chai.OperatorComparable, operator: Chai.Operator, val2: Chai.OperatorComparable, message?: string): void;
    closeTo(actual: number, expected: number, delta: number, message?: string): void;
    approximately(act: number, exp: number, delta: number, message?: string): void;
    sameMembers<T>(set1: T[], set2: T[], message?: string): void;
    sameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;
    notSameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;
    sameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;
    notSameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;
    sameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;
    notSameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;
    includeOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;
    notIncludeOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;
    includeDeepOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;
    notIncludeDeepOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;
    includeMembers<T>(superset: T[], subset: T[], message?: string): void;
    notIncludeMembers<T>(superset: T[], subset: T[], message?: string): void;
    includeDeepMembers<T>(superset: T[], subset: T[], message?: string): void;
    notIncludeDeepMembers<T>(superset: T[], subset: T[], message?: string): void;
    oneOf<T>(inList: T, list: T[], message?: string): void;
    changes<T>(modifier: Function, object: T, property: string, message?: string): void;
    changesBy<T>(modifier: Function, object: T, property: string, change: number, message?: string): void;
    changesBy<T>(modifier: Function, object: T, change: number, message?: string): void;
    doesNotChange<T>(modifier: Function, object: T, property: string, message?: string): void;
    increases<T>(modifier: Function, object: T, property: string, message?: string): void;
    increasesBy<T>(modifier: Function, object: T, property: string, change: number, message?: string): void;
    increasesBy<T>(modifier: Function, object: T, change: number, message?: string): void;
    doesNotIncrease<T>(modifier: Function, object: T, property: string, message?: string): void;
    increasesButNotBy<T>(modifier: Function, object: T, property: string, change: number, message?: string): void;
    increasesButNotBy<T>(modifier: Function, object: T, change: number, message?: string): void;
    decreases<T>(modifier: Function, object: T, property: string, message?: string): void;
    decreasesBy<T>(modifier: Function, object: T, property: string, change: number, message?: string): void;
    decreasesBy<T>(modifier: Function, object: T, change: number, message?: string): void;
    doesNotDecrease<T>(modifier: Function, object: T, property: string, message?: string): void;
    doesNotDecreaseBy<T>(modifier: Function, object: T, property: string, change: number, message?: string): void;
    doesNotDecreaseBy<T>(modifier: Function, object: T, change: number, message?: string): void;
    decreasesButNotBy<T>(modifier: Function, object: T, property: string, change: number, message?: string): void;
    decreasesButNotBy<T>(modifier: Function, object: T, change: number, message?: string): void;
    ifError<T>(object: T, message?: string): void;
    isExtensible<T>(object: T, message?: string): void;
    extensible<T>(object: T, message?: string): void;
    isNotExtensible<T>(object: T, message?: string): void;
    notExtensible<T>(object: T, message?: string): void;
    isSealed<T>(object: T, message?: string): void;
    sealed<T>(object: T, message?: string): void;
    isNotSealed<T>(object: T, message?: string): void;
    notSealed<T>(object: T, message?: string): void;
    isFrozen<T>(object: T, message?: string): void;
    frozen<T>(object: T, message?: string): void;
    isNotFrozen<T>(object: T, message?: string): void;
    notFrozen<T>(object: T, message?: string): void;
    isEmpty<T>(object: T, message?: string): void;
    isNotEmpty<T>(object: T, message?: string): void;
    hasAnyKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    hasAllKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    containsAllKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    doesNotHaveAnyKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    doesNotHaveAllKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    hasAnyDeepKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    hasAllDeepKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    containsAllDeepKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    doesNotHaveAnyDeepKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    doesNotHaveAllDeepKeys<T>(object: T, keys: Array<Object | string> | {
        [key: string]: any;
    }, message?: string): void;
    nestedProperty<T>(object: T, property: string, message?: string): void;
    notNestedProperty<T>(object: T, property: string, message?: string): void;
    nestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;
    notNestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;
    deepNestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;
    notDeepNestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;
    eventually: Chai.PromisedAssert;
    isFulfilled(promise: PromiseLike<any>, message?: string): PromiseLike<void>;
    becomes(promise: PromiseLike<any>, expected: any, message?: string): PromiseLike<void>;
    doesNotBecome(promise: PromiseLike<any>, expected: any, message?: string): PromiseLike<void>;
    isRejected(promise: PromiseLike<any>, message?: string): PromiseLike<void>;
    isRejected(promise: PromiseLike<any>, expected: any, message?: string): PromiseLike<void>;
    isRejected(promise: PromiseLike<any>, match: RegExp, message?: string): PromiseLike<void>;
    notify(fn: Function): PromiseLike<void>;
};
